{"version":3,"sources":["webpack:///./node_modules/xtend/immutable.js","webpack:///./node_modules/node-libs-browser/node_modules/process/browser.js","webpack:///./node_modules/unist-util-visit/index.js","webpack:///./node_modules/core-js/modules/es6.string.bold.js","webpack:///./node_modules/react-markdown/lib/react-markdown.js","webpack:///./node_modules/extend/index.js","webpack:///./node_modules/is-decimal/index.js","webpack:///./node_modules/unist-util-visit-parents/index.js","webpack:///./node_modules/unified/index.js","webpack:///./node_modules/events/events.js","webpack:///./node_modules/has/src/index.js","webpack:///./node_modules/function-bind/index.js","webpack:///./node_modules/function-bind/implementation.js","webpack:///./node_modules/once/once.js","webpack:///./node_modules/wrappy/wrappy.js","webpack:///./node_modules/bail/index.js","webpack:///./node_modules/vfile/index.js","webpack:///./node_modules/path-browserify/index.js","webpack:///./node_modules/trough/index.js","webpack:///./node_modules/trough/wrap.js","webpack:///./node_modules/remark-parse/index.js","webpack:///./node_modules/unherit/index.js","webpack:///./node_modules/inherits/inherits_browser.js","webpack:///./node_modules/remark-parse/lib/parser.js","webpack:///./node_modules/parse-entities/index.js","webpack:///./node_modules/is-hexadecimal/index.js","webpack:///./node_modules/is-alphanumerical/index.js","webpack:///./node_modules/is-alphabetical/index.js","webpack:///./node_modules/parse-entities/decode-entity.browser.js","webpack:///./node_modules/repeat-string/index.js","webpack:///./node_modules/trim/index.js","webpack:///./node_modules/trim-trailing-lines/index.js","webpack:///./node_modules/vfile-location/index.js","webpack:///./node_modules/unist-util-remove-position/index.js","webpack:///./node_modules/unist-util-is/index.js","webpack:///./node_modules/collapse-white-space/index.js","webpack:///./node_modules/remark-parse/lib/defaults.js","webpack:///./node_modules/mdast-add-list-metadata/index.js","webpack:///./node_modules/react-markdown/lib/plugins/naive-html.js","webpack:///./node_modules/react-markdown/lib/plugins/disallow-node.js","webpack:///./node_modules/react-markdown/lib/ast-to-react.js","webpack:///./node_modules/react-markdown/lib/wrap-table-rows.js","webpack:///./node_modules/react-markdown/lib/get-definitions.js","webpack:///./node_modules/react-markdown/lib/uri-transformer.js","webpack:///./node_modules/react-markdown/lib/renderers.js","webpack:///./node_modules/react-markdown/lib/symbols.js"],"names":["module","exports","target","i","arguments","length","source","key","hasOwnProperty","call","Object","prototype","cachedSetTimeout","cachedClearTimeout","process","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","this","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","push","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","visit","visitParents","__webpack_require__","CONTINUE","SKIP","EXIT","tree","test","visitor","reverse","node","parents","parent","index","children","indexOf","createHTML","_toConsumableArray","arr","isArray","arr2","_arrayWithoutHoles","iter","Symbol","iterator","toString","from","_iterableToArray","TypeError","_nonIterableSpread","xtend","unified","parse","PropTypes","addListMetadata","naiveHtml","disallowNode","astToReact","wrapTableRows","getDefinitions","uriTransformer","defaultRenderers","symbols","allTypes","keys","ReactMarkdown","props","src","allowedTypes","disallowedTypes","renderers","rawAst","plugins","reduce","applyParserPlugin","renderProps","definitions","ast","filter","type","removalMethod","unwrapDisallowed","ofType","allowNode","ifNotMatch","renderHtml","escapeHtml","skipHtml","hasHtmlParser","astPlugins","some","item","plugin","identity","HtmlParser","determineAstPlugins","parser","use","defaultProps","sourcePos","rawSourcePos","transformLinkUri","propTypes","className","string","bool","func","arrayOf","oneOf","oneOfType","linkTarget","transformImageUri","object","types","hasOwn","toStr","defineProperty","gOPD","getOwnPropertyDescriptor","isPlainObject","obj","hasOwnConstructor","hasIsPrototypeOf","constructor","setProperty","options","enumerable","configurable","value","newValue","writable","getProperty","extend","copy","copyIsArray","clone","deep","character","code","charCodeAt","is","one","result","child","step","all","global","events","has","bail","vfile","trough","attachers","transformers","namespace","chunks","emitter","EventEmitter","ended","concrete","settings","processor","destination","data","assertParser","isFunction","Parser","assertCompiler","compiler","Compiler","compile","assertConcrete","assertNode","isNode","assertDone","complete","done","file","pipeline","err","write","chunk","encoding","callback","abstract","slice","params","transformer","readable","end","join","messages","contents","pipe","dest","onend","ondata","cleanup","onerror","handlers","_events","error","_isStdio","stringify","isFile","p","ctx","next","fn","_maxListeners","undefined","arg","isObject","isUndefined","defaultMaxListeners","setMaxListeners","n","isNaN","er","handler","context","listener","m","newListener","warned","console","trace","fired","g","list","position","splice","listenerCount","evlistener","bind","Function","implementation","that","bound","boundLength","Math","max","boundArgs","Empty","wrappy","f","called","onceStrict","onceError","strict","proto","cb","forEach","k","wrapper","ret","SEPARATOR","sep","VFileMessage","reason","message","VFileMessagePrototype","line","column","VFile","hasFailed","filePath","separator","directory","filename","extension","charAt","filePathFactory","history","move","stack","fatal","basename","after","before","ruleId","range","location","start","warn","fail","quiet","space","normalizeArray","parts","allowAboveRoot","up","last","unshift","splitPathRe","splitPath","exec","xs","res","resolve","resolvedPath","resolvedAbsolute","path","split","normalize","isAbsolute","trailingSlash","substr","paths","relative","to","trim","fromParts","toParts","min","samePartsLength","outputParts","delimiter","dirname","root","ext","extname","str","wrap","fns","middleware","input","values","pos","invoked","then","unherit","inherits","Super","Of","From","parameters","create","ctor","superCtor","super_","TempCtor","decode","repeat","trimTrailingLines","vfileLocation","removePosition","collapseWhiteSpace","defaultOptions","escapes","blockElements","TAB_SIZE","CODE_INDENT_LENGTH","MIN_FENCE_COUNT","MAX_ATX_COUNT","MAX_LINE_HEADING_INDENT","THEMATIC_BREAK_MARKER_COUNT","MIN_CLOSING_HTML_NEWLINE_COUNT","MIN_BREAK_LENGTH","MIN_TABLE_COLUMNS","MIN_TABLE_ROWS","ERR_INFINITE_LOOP","ERR_MISSING_LOCATOR","ERR_INCORRECTLY_EATEN","EXPRESSION_BULLET","EXPRESSION_PEDANTIC_BULLET","EXPRESSION_INITIAL_INDENT","EXPRESSION_INITIAL_TAB","EXPRESSION_HTML_LINK_OPEN","EXPRESSION_HTML_LINK_CLOSE","EXPRESSION_LOOSE_LIST_ITEM","EXPRESSION_TASK_ITEM","EXPRESSION_LINE_BREAKS","C_BACKSLASH","C_UNDERSCORE","C_ASTERISK","C_TICK","C_AT_SIGN","C_HASH","C_DASH","C_DOT","C_PIPE","C_DOUBLE_QUOTE","C_SINGLE_QUOTE","C_COMMA","C_SLASH","C_COLON","C_SEMI_COLON","C_QUESTION_MARK","C_CARET","C_EQUALS","C_EXCLAMATION_MARK","C_TILDE","C_LT","C_GT","C_BRACKET_OPEN","C_BRACKET_CLOSE","C_PAREN_OPEN","C_PAREN_CLOSE","C_SPACE","C_FORM_FEED","C_NEWLINE","C_CARRIAGE_RETURN","C_TAB","C_VERTICAL_TAB","C_NO_BREAK_SPACE","C_OGHAM_SPACE","C_MONGOLIAN_VOWEL_SEPARATOR","C_EN_QUAD","C_EM_QUAD","C_EN_SPACE","C_EM_SPACE","C_THREE_PER_EM_SPACE","C_FOUR_PER_EM_SPACE","C_SIX_PER_EM_SPACE","C_FIGURE_SPACE","C_PUNCTUATION_SPACE","C_THIN_SPACE","C_HAIR_SPACE","C_LINE_SEPARATOR","C_PARAGRAPH_SEPARATOR","C_NARROW_NO_BREAK_SPACE","C_IDEOGRAPHIC_SPACE","C_ZERO_WIDTH_NO_BREAK_SPACE","C_X_LOWER","CC_A_LOWER","CC_A_UPPER","CC_Z_LOWER","CC_Z_UPPER","CC_0","CC_9","MAILTO_PROTOCOL","PROTOCOLS","PROTOCOLS_LENGTH","YAML_FENCE","CODE_INDENT","EMPTY","COMMENT_START","COMMENT_END","CDATA_START","CDATA_END","COMMENT_END_CHAR","CDATA_END_CHAR","COMMENT_START_LENGTH","COMMENT_END_LENGTH","CDATA_START_LENGTH","CDATA_END_LENGTH","T_THEMATIC_BREAK","T_HTML","T_YAML","T_TABLE","T_TABLE_CELL","T_TABLE_HEADER","T_TABLE_ROW","T_PARAGRAPH","T_TEXT","T_CODE","T_LIST","T_LIST_ITEM","T_DEFINITION","T_FOOTNOTE_DEFINITION","T_HEADING","T_BLOCKQUOTE","T_LINK","T_IMAGE","T_FOOTNOTE","T_STRONG","T_EMPHASIS","T_DELETE","T_INLINE_CODE","T_BREAK","TABLE_ALIGN_LEFT","TABLE_ALIGN_CENTER","TABLE_ALIGN_RIGHT","TABLE_ALIGN_NONE","REFERENCE_TYPE_SHORTCUT","REFERENCE_TYPE_COLLAPSED","REFERENCE_TYPE_FULL","INDENTATION_CHARACTERS","EMPHASIS_MARKERS","RULE_MARKERS","LIST_UNORDERED_MARKERS","LIST_ORDERED_MARKERS","LIST_ORDERED_COMMONMARK_MARKERS","LINK_MARKERS","COMMONMARK_LINK_MARKERS","SETEXT_MARKERS","LIST_ITEM_MAP","isAlphabetic","isNumeric","isWordCharacter","isWhiteSpace","isUnquotedAttributeCharacter","isDoubleQuotedAttributeCharacter","isSingleQuotedAttributeCharacter","isEnclosedURLCharacter","isUnclosedURLCharacter","toLowerCase","toggle","state","self","current","true","indent","replacer","$0","replace","false","bullet","rest","lines","trimmedLines","$1","$2","$3","$4","Number","maximum","indentation","stops","padding","minIndent","Infinity","matrix","getIndent","shift","removeIndentation","MERGEABLE_NODES","mergeable","size","floor","eatHTMLComment","hasNonDash","commonmark","eatHTMLCDATA","toUpperCase","eatHTMLProcessingInstruction","eatHTMLDeclaration","subqueue","eatHTMLClosingTag","isBlock","eatHTMLOpeningTag","hasEquals","tokenizeDefinition","eat","silent","beforeURL","beforeTitle","identifier","url","subvalue","raw","descape","tokenizeYAMLFrontMatter","content","yaml","renderRaw","tokenizeFootnoteDefinition","now","footnotes","offset","renderFootnoteDefinition","tokenizeTable","alignments","alignment","row","hasDash","align","cell","preamble","count","opening","lineCount","rows","table","lineIndex","pipeIndex","first","gfm","reset","renderParent","renderInline","tokenizeEscape","escape","renderVoid","tokenizeAutoLink","hasAtCharacter","link","tokenize","inlineTokenizers","renderLink","tokenizeURL","protocol","match","parenCount","nextCharacter","tokenizeInlineHTML","inLink","locateLink","fromIndex","image","tokenizeLink","closed","hasMarker","markers","isImage","depth","openCount","tokenizeReference","exitLink","bracketed","intro","referenceType","renderFootnote","enterLink","tokenizeInline","alt","tokenizeStrong","pedantic","prev","tokenizeEmphasis","tokenizeDeletion","previous","preceding","tokenizeInlineCode","contentQueue","openingCount","found","tickQueue","tokenizeBreak","breaks","scope","inBlock","inList","atStart","toOffset","handleWarning","decoder","warning","text","reference","textContext","referenceContext","decodeFactory","setOptions","tokenizeFactory","add","method","matched","valueLength","tokens","methods","tokenizers","updatePosition","lastIndex","Position","getOffset","combined","l","substring","validateEat","exitStart","onlyAtStart","notInList","notInBlock","notInLink","eof","blockquote","locator","asterisk","underscore","default","String","renderBlock","enterList","enterBlock","tokenizeBlock","isLink","renderCodeBlock","language","lang","renderBlockquote","exitBlockquote","renderListItem","task","checked","loose","renderHeading","blockTokenizers","yamlFrontMatter","newline","indentedCode","blankQueue","subvalueQueue","fencedCode","fenceCount","flag","exdentedContent","closing","exdentedClosing","nextIndex","startIndex","prefixed","indents","atxHeading","setextHeading","thematicBreak","html","definition","footnote","markerCount","ordered","currentMarker","prevEmpty","empty","items","allLines","emptyLines","enterTop","isLoose","indented","parseInt","trail","paragraph","left","blockMethods","autoLink","strong","emphasis","deletion","break","tokenizer","inlineMethods","legacy","invalid","decimal","hexadecimal","alphanumerical","decodeEntity","option","defaults","entityCharacters","namedEntity","terminated","characters","following","output","entity","begin","diff","additional","nonTerminated","handleText","handleReference","warningContext","MESSAGES","at","flush","NAMED","HEXADECIMAL","DECIMAL","TESTS","own","NAMED_UNKNOWN","NAMED_NOT_TERMINATED","NAMED_EMPTY","attribute","NUMERIC_NOT_TERMINATED","BASE","NUMERIC_PROHIBITED","NUMERIC_DISALLOWED","disallowed","fromCharCode","NUMERIC_EMPTY","alphabetical","el","char","document","createElement","innerHTML","textContent","cache","num","right","val","offsetToPositionFactory","indices","positionToOffsetFactory","toPosition","hard","soft","force","convert","Boolean","typeFactory","ok","tests","checks","results","convertAll","hasParent","hasIndex","check","visitWithParents","listNode","selfClosingRe","simpleTagRe","open","currentParent","selfClosing","getSelfClosing","tag","getSimpleTag","matching","matchingTag","findAndPull","fromNode","toNode","toIndex","virtual","untangle","mode","disallow","React","renderer","Fragment","isReactFragment","nodeProps","opts","isTagRenderer","map","sourcePosition","includeNodeIndex","parentChildCount","ref","assignDefined","nodeKey","level","tight","unwrapParagraphs","getListItemChildren","childNode","inline","href","columnAlignment","isHeader","element","parsedChildren","cloneElement","mergeNodeChildren","getNodeProps","attrs","defs","protocols","uri","colon","supportsStringRender","SimpleRenderer","getCoreProps","data-sourcepos","delete","linkReference","imageReference","tableHead","tableBody","tableRow","tableCell","style","textAlign","coreProps","useFragment","listItem","checkbox","readOnly","heading","inlineCode","comp","dangerouslySetInnerHTML","__html","virtualHtml","parsedHtml"],"mappings":"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","file":"1-4aee033104006ce5381a.js","sourcesContent":["module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","'use strict'\n\nmodule.exports = visit\n\nvar visitParents = require('unist-util-visit-parents')\n\nvar CONTINUE = visitParents.CONTINUE\nvar SKIP = visitParents.SKIP\nvar EXIT = visitParents.EXIT\n\nvisit.CONTINUE = CONTINUE\nvisit.SKIP = SKIP\nvisit.EXIT = EXIT\n\nfunction visit(tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    visitor = test\n    test = null\n  }\n\n  visitParents(tree, test, overload, reverse)\n\n  function overload(node, parents) {\n    var parent = parents[parents.length - 1]\n    var index = parent ? parent.children.indexOf(node) : null\n    return visitor(node, index, parent)\n  }\n}\n","'use strict';\n// B.2.3.5 String.prototype.bold()\nrequire('./_string-html')('bold', function (createHTML) {\n  return function bold() {\n    return createHTML(this, 'b', '', '');\n  };\n});\n","'use strict';\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nvar xtend = require('xtend');\n\nvar unified = require('unified');\n\nvar parse = require('remark-parse');\n\nvar PropTypes = require('prop-types');\n\nvar addListMetadata = require('mdast-add-list-metadata');\n\nvar naiveHtml = require('./plugins/naive-html');\n\nvar disallowNode = require('./plugins/disallow-node');\n\nvar astToReact = require('./ast-to-react');\n\nvar wrapTableRows = require('./wrap-table-rows');\n\nvar getDefinitions = require('./get-definitions');\n\nvar uriTransformer = require('./uri-transformer');\n\nvar defaultRenderers = require('./renderers');\n\nvar symbols = require('./symbols');\n\nvar allTypes = Object.keys(defaultRenderers);\n\nvar ReactMarkdown = function ReactMarkdown(props) {\n  var src = props.source || props.children || '';\n\n  if (props.allowedTypes && props.disallowedTypes) {\n    throw new Error('Only one of `allowedTypes` and `disallowedTypes` should be defined');\n  }\n\n  var renderers = xtend(defaultRenderers, props.renderers);\n  var plugins = [parse].concat(props.plugins || []);\n  var parser = plugins.reduce(applyParserPlugin, unified());\n  var rawAst = parser.parse(src);\n  var renderProps = xtend(props, {\n    renderers: renderers,\n    definitions: getDefinitions(rawAst)\n  });\n  var astPlugins = determineAstPlugins(props);\n  var ast = astPlugins.reduce(function (node, plugin) {\n    return plugin(node, renderProps);\n  }, rawAst);\n  return astToReact(ast, renderProps);\n};\n\nfunction applyParserPlugin(parser, plugin) {\n  return Array.isArray(plugin) ? parser.use.apply(parser, _toConsumableArray(plugin)) : parser.use(plugin);\n}\n\nfunction determineAstPlugins(props) {\n  var plugins = [wrapTableRows, addListMetadata()];\n  var disallowedTypes = props.disallowedTypes;\n\n  if (props.allowedTypes) {\n    disallowedTypes = allTypes.filter(function (type) {\n      return type !== 'root' && props.allowedTypes.indexOf(type) === -1;\n    });\n  }\n\n  var removalMethod = props.unwrapDisallowed ? 'unwrap' : 'remove';\n\n  if (disallowedTypes && disallowedTypes.length > 0) {\n    plugins.push(disallowNode.ofType(disallowedTypes, removalMethod));\n  }\n\n  if (props.allowNode) {\n    plugins.push(disallowNode.ifNotMatch(props.allowNode, removalMethod));\n  }\n\n  var renderHtml = !props.escapeHtml && !props.skipHtml;\n  var hasHtmlParser = (props.astPlugins || []).some(function (item) {\n    var plugin = Array.isArray(item) ? item[0] : item;\n    return plugin.identity === symbols.HtmlParser;\n  });\n\n  if (renderHtml && !hasHtmlParser) {\n    plugins.push(naiveHtml);\n  }\n\n  return props.astPlugins ? plugins.concat(props.astPlugins) : plugins;\n}\n\nReactMarkdown.defaultProps = {\n  renderers: {},\n  escapeHtml: true,\n  skipHtml: false,\n  sourcePos: false,\n  rawSourcePos: false,\n  transformLinkUri: uriTransformer,\n  astPlugins: [],\n  plugins: []\n};\nReactMarkdown.propTypes = {\n  className: PropTypes.string,\n  source: PropTypes.string,\n  children: PropTypes.string,\n  sourcePos: PropTypes.bool,\n  rawSourcePos: PropTypes.bool,\n  escapeHtml: PropTypes.bool,\n  skipHtml: PropTypes.bool,\n  allowNode: PropTypes.func,\n  allowedTypes: PropTypes.arrayOf(PropTypes.oneOf(allTypes)),\n  disallowedTypes: PropTypes.arrayOf(PropTypes.oneOf(allTypes)),\n  transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n  linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  transformImageUri: PropTypes.func,\n  astPlugins: PropTypes.arrayOf(PropTypes.func),\n  unwrapDisallowed: PropTypes.bool,\n  renderers: PropTypes.object,\n  plugins: PropTypes.array\n};\nReactMarkdown.types = allTypes;\nReactMarkdown.renderers = defaultRenderers;\nReactMarkdown.uriTransformer = uriTransformer;\nmodule.exports = ReactMarkdown;","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","'use strict'\n\nmodule.exports = decimal\n\n/* Check if the given character code, or the character\n * code at the first character, is decimal. */\nfunction decimal(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return code >= 48 && code <= 57 /* 0-9 */\n}\n","'use strict'\n\nmodule.exports = visitParents\n\nvar is = require('unist-util-is')\n\nvar CONTINUE = true\nvar SKIP = 'skip'\nvar EXIT = false\n\nvisitParents.CONTINUE = CONTINUE\nvisitParents.SKIP = SKIP\nvisitParents.EXIT = EXIT\n\nfunction visitParents(tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    visitor = test\n    test = null\n  }\n\n  one(tree, null, [])\n\n  // Visit a single node.\n  function one(node, index, parents) {\n    var result\n\n    if (!test || is(test, node, index, parents[parents.length - 1] || null)) {\n      result = visitor(node, parents)\n\n      if (result === EXIT) {\n        return result\n      }\n    }\n\n    if (node.children && result !== SKIP) {\n      return all(node.children, parents.concat(node)) === EXIT ? EXIT : result\n    }\n\n    return result\n  }\n\n  // Visit children in `parent`.\n  function all(children, parents) {\n    var min = -1\n    var step = reverse ? -1 : 1\n    var index = (reverse ? children.length : min) + step\n    var child\n    var result\n\n    while (index > min && index < children.length) {\n      child = children[index]\n      result = child && one(child, index, parents)\n\n      if (result === EXIT) {\n        return result\n      }\n\n      index = typeof result === 'number' ? result : index + step\n    }\n  }\n}\n","/**\n * @author Titus Wormer\n * @copyright 2015 Titus Wormer\n * @license MIT\n * @module unified\n * @fileoverview Pluggable text processing interface.\n */\n\n'use strict';\n\n/* Dependencies. */\nvar events = require('events');\nvar has = require('has');\nvar once = require('once');\nvar extend = require('extend');\nvar bail = require('bail');\nvar vfile = require('vfile');\nvar trough = require('trough');\n\n/* Expose an abstract processor. */\nmodule.exports = unified().abstract();\n\n/* Methods. */\nvar slice = [].slice;\n\n/* Process pipeline. */\nvar pipeline = trough()\n  .use(function (p, ctx) {\n    ctx.tree = p.parse(ctx.file, ctx.options);\n  })\n  .use(function (p, ctx, next) {\n    p.run(ctx.tree, ctx.file, function (err, tree, file) {\n      if (err) {\n        next(err);\n      } else {\n        ctx.tree = tree;\n        ctx.file = file;\n        next();\n      }\n    });\n  })\n  .use(function (p, ctx) {\n    ctx.file.contents = p.stringify(ctx.tree, ctx.file, ctx.options);\n  });\n\n/**\n * Function to create the first processor.\n *\n * @return {Function} - First processor.\n */\nfunction unified() {\n  var attachers = [];\n  var transformers = trough();\n  var namespace = {};\n  var chunks = [];\n  var emitter = new events.EventEmitter();\n  var ended = false;\n  var concrete = true;\n  var settings;\n  var key;\n\n  /**\n   * Create a new processor based on the processor\n   * in the current scope.\n   *\n   * @return {Processor} - New concrete processor based\n   *   on the descendant processor.\n   */\n  function processor() {\n    var destination = unified();\n    var length = attachers.length;\n    var index = -1;\n\n    while (++index < length) {\n      destination.use.apply(null, attachers[index]);\n    }\n\n    destination.data(extend(true, {}, namespace));\n\n    return destination;\n  }\n\n  /* Mix in methods. */\n  for (key in emitter) {\n    processor[key] = emitter[key];\n  }\n\n  /* Helpers. */\n\n  /**\n   * Assert a parser is available.\n   *\n   * @param {string} name - Name of callee.\n   */\n  function assertParser(name) {\n    if (!isParser(processor.Parser)) {\n      throw new Error('Cannot `' + name + '` without `Parser`');\n    }\n  }\n\n  /**\n   * Assert a compiler is available.\n   *\n   * @param {string} name - Name of callee.\n   */\n  function assertCompiler(name) {\n    if (!isCompiler(processor.Compiler)) {\n      throw new Error('Cannot `' + name + '` without `Compiler`');\n    }\n  }\n\n  /**\n   * Assert the processor is concrete.\n   *\n   * @param {string} name - Name of callee.\n   */\n  function assertConcrete(name) {\n    if (!concrete) {\n      throw new Error(\n        'Cannot ' +\n        (name ? 'invoke `' + name + '` on' : 'pipe into') +\n        ' abstract processor.\\n' +\n        'To make the processor concrete, invoke it: ' +\n        'use `processor()` instead of `processor`.'\n      );\n    }\n  }\n\n  /**\n   * Assert `node` is a Unist node.\n   *\n   * @param {*} node - Value to check.\n   */\n  function assertNode(node) {\n    if (!isNode(node)) {\n      throw new Error('Expected node, got `' + node + '`');\n    }\n  }\n\n  /**\n   * Assert, if no `done` is given, that `complete` is\n   * `true`.\n   *\n   * @param {string} name - Name of callee.\n   * @param {boolean} complete - Whether an async process\n   *   is complete.\n   * @param {Function?} done - Optional handler of async\n   *   results.\n   */\n  function assertDone(name, complete, done) {\n    if (!complete && !done) {\n      throw new Error(\n        'Expected `done` to be given to `' + name + '` ' +\n        'as async plug-ins are used'\n      );\n    }\n  }\n\n  /* Throw as early as possible.\n   * As events are triggered synchroneously, the stack\n   * is preserved. */\n  processor.on('pipe', function () {\n    assertConcrete();\n  });\n\n  /**\n   * Abstract: used to signal an abstract processor which\n   * should made concrete before using.\n   *\n   * For example, take unified itself.  Its abstract.\n   * Plug-ins should not be added to it.  Rather, it should\n   * be made concrete (by invoking it) before modifying it.\n   *\n   * In essence, always invoke this when exporting a\n   * processor.\n   *\n   * @return {Processor} - The operated on processor.\n   */\n  function abstract() {\n    concrete = false;\n\n    return processor;\n  }\n\n  /**\n   * Data management.\n   *\n   * Getter / setter for processor-specific informtion.\n   *\n   * @param {string} key - Key to get or set.\n   * @param {*} value - Value to set.\n   * @return {*} - Either the operator on processor in\n   *   setter mode; or the value stored as `key` in\n   *   getter mode.\n   */\n  function data(key, value) {\n    assertConcrete('data');\n\n    if (typeof key === 'string') {\n      /* Set `key`. */\n      if (arguments.length === 2) {\n        namespace[key] = value;\n\n        return processor;\n      }\n\n      /* Get `key`. */\n      return (has(namespace, key) && namespace[key]) || null;\n    }\n\n    /* Get space. */\n    if (!key) {\n      return namespace;\n    }\n\n    /* Set space. */\n    namespace = key;\n\n    return processor;\n  }\n\n  /**\n   * Plug-in management.\n   *\n   * Pass it:\n   * *   an attacher and options,\n   * *   a list of attachers and options for all of them;\n   * *   a tuple of one attacher and options.\n   * *   a matrix: list containing any of the above and\n   *     matrices.\n   *\n   * @param {...*} value - See description.\n   * @return {Processor} - The operated on processor.\n   */\n  function use(value) {\n    var args = slice.call(arguments, 0);\n    var params = args.slice(1);\n    var index;\n    var length;\n    var transformer;\n\n    assertConcrete('use');\n\n    /* Multiple attachers. */\n    if ('length' in value && !isFunction(value)) {\n      index = -1;\n      length = value.length;\n\n      if (!isFunction(value[0])) {\n        /* Matrix of things. */\n        while (++index < length) {\n          use(value[index]);\n        }\n      } else if (isFunction(value[1])) {\n        /* List of things. */\n        while (++index < length) {\n          use.apply(null, [value[index]].concat(params));\n        }\n      } else {\n        /* Arguments. */\n        use.apply(null, value);\n      }\n\n      return processor;\n    }\n\n    /* Store attacher. */\n    attachers.push(args);\n\n    /* Single attacher. */\n    transformer = value.apply(null, [processor].concat(params));\n\n    if (isFunction(transformer)) {\n      transformers.use(transformer);\n    }\n\n    return processor;\n  }\n\n  /**\n   * Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the\n   * processor.\n   *\n   * @param {(string|VFile)?} [file] - File to process.\n   * @param {Object?} [options] - Configuration.\n   * @return {Node} - Unist node.\n   */\n  function parse(file, options) {\n    assertConcrete('parse');\n    assertParser('parse');\n\n    return new processor.Parser(vfile(file), options, processor).parse();\n  }\n\n  /**\n   * Run transforms on a Unist node representation of a file\n   * (in string or VFile representation).\n   *\n   * @param {Node} node - Unist node.\n   * @param {(string|VFile)?} [file] - File representation.\n   * @param {Function?} [done] - Callback.\n   * @return {Node} - The given or resulting Unist node.\n   */\n  function run(node, file, done) {\n    var complete = false;\n    var result;\n\n    assertConcrete('run');\n    assertNode(node);\n\n    result = node;\n\n    if (!done && file && !isFile(file)) {\n      done = file;\n      file = null;\n    }\n\n    transformers.run(node, vfile(file), function (err, tree, file) {\n      complete = true;\n      result = tree || node;\n\n      (done || bail)(err, tree, file);\n    });\n\n    assertDone('run', complete, done);\n\n    return result;\n  }\n\n  /**\n   * Stringify a Unist node representation of a file\n   * (in string or VFile representation) into a string\n   * using the `Compiler` on the processor.\n   *\n   * @param {Node} node - Unist node.\n   * @param {(string|VFile)?} [file] - File representation.\n   * @param {Object?} [options] - Configuration.\n   * @return {string} - String representation.\n   */\n  function stringify(node, file, options) {\n    assertConcrete('stringify');\n    assertCompiler('stringify');\n    assertNode(node);\n\n    if (!options && file && !isFile(file)) {\n      options = file;\n      file = null;\n    }\n\n    return new processor.Compiler(vfile(file), options, processor).compile(node);\n  }\n\n  /**\n   * Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the processor,\n   * then run transforms on that node, and compile the\n   * resulting node using the `Compiler` on the processor,\n   * and store that result on the VFile.\n   *\n   * @param {(string|VFile)?} file - File representation.\n   * @param {Object?} [options] - Configuration.\n   * @param {Function?} [done] - Callback.\n   * @return {VFile} - The given or resulting VFile.\n   */\n  function process(file, options, done) {\n    var complete = false;\n\n    assertConcrete('process');\n    assertParser('process');\n    assertCompiler('process');\n\n    if (!done && isFunction(options)) {\n      done = options;\n      options = null;\n    }\n\n    file = vfile(file);\n\n    pipeline.run(processor, {\n      file: file,\n      options: options || {}\n    }, function (err) {\n      complete = true;\n\n      if (done) {\n        done(err, file);\n      } else {\n        bail(err);\n      }\n    });\n\n    assertDone('process', complete, done);\n\n    return file;\n  }\n\n  /* Streams. */\n\n  /**\n   * Write a chunk into memory.\n   *\n   * @param {(Buffer|string)?} chunk - Value to write.\n   * @param {string?} [encoding] - Encoding.\n   * @param {Function?} [callback] - Callback.\n   * @return {boolean} - Whether the write was succesful.\n   */\n  function write(chunk, encoding, callback) {\n    assertConcrete('write');\n\n    if (isFunction(encoding)) {\n      callback = encoding;\n      encoding = null;\n    }\n\n    if (ended) {\n      throw new Error('Did not expect `write` after `end`');\n    }\n\n    chunks.push((chunk || '').toString(encoding || 'utf8'));\n\n    if (callback) {\n      callback();\n    }\n\n    /* Signal succesful write. */\n    return true;\n  }\n\n  /**\n   * End the writing.  Passes all arguments to a final\n   * `write`.  Starts the process, which will trigger\n   * `error`, with a fatal error, if any; `data`, with\n   * the generated document in `string` form, if\n   * succesful.  If messages are triggered during the\n   * process, those are triggerd as `warning`s.\n   *\n   * @return {boolean} - Whether the last write was\n   *   succesful.\n   */\n  function end() {\n    assertConcrete('end');\n    assertParser('end');\n    assertCompiler('end');\n\n    write.apply(null, arguments);\n\n    ended = true;\n\n    process(chunks.join(''), settings, function (err, file) {\n      var messages = file.messages;\n      var length = messages.length;\n      var index = -1;\n\n      chunks = settings = null;\n\n      /* Trigger messages as warnings, except for fatal error. */\n      while (++index < length) {\n        if (messages[index] !== err) {\n          processor.emit('warning', messages[index]);\n        }\n      }\n\n      if (err) {\n        /* Dont enter an infinite error throwing loop. */\n        global.setTimeout(function () {\n          processor.emit('error', err);\n        }, 4);\n      } else {\n        processor.emit('data', file.contents);\n        processor.emit('end');\n      }\n    });\n\n    return true;\n  }\n\n  /**\n   * Pipe the processor into a writable stream.\n   *\n   * Basically `Stream#pipe`, but inlined and\n   * simplified to keep the bundled size down.\n   *\n   * @see https://github.com/nodejs/node/blob/master/lib/stream.js#L26\n   *\n   * @param {Stream} dest - Writable stream.\n   * @param {Object?} [options] - Processing\n   *   configuration.\n   * @return {Stream} - The destination stream.\n   */\n  function pipe(dest, options) {\n    var onend = once(function () {\n      if (dest.end) {\n        dest.end();\n      }\n    });\n\n    assertConcrete('pipe');\n\n    settings = options || {};\n\n    /**\n     * Handle data.\n     *\n     * @param {*} chunk - Data to pass through.\n     */\n    function ondata(chunk) {\n      if (dest.writable) {\n        dest.write(chunk);\n      }\n    }\n\n    /**\n     * Clean listeners.\n     */\n    function cleanup() {\n      processor.removeListener('data', ondata);\n      processor.removeListener('end', onend);\n      processor.removeListener('error', onerror);\n      processor.removeListener('end', cleanup);\n      processor.removeListener('close', cleanup);\n\n      dest.removeListener('error', onerror);\n      dest.removeListener('close', cleanup);\n    }\n\n    /**\n     * Close dangling pipes and handle unheard errors.\n     *\n     * @param {Error} err - Exception.\n     */\n    function onerror(err) {\n      var handlers = processor._events.error;\n\n      cleanup();\n\n      /* Cannot use `listenerCount` in node <= 0.12. */\n      if (!handlers || !handlers.length || handlers === onerror) {\n        throw err; /* Unhandled stream error in pipe. */\n      }\n    }\n\n    processor.on('data', ondata);\n    processor.on('error', onerror);\n    processor.on('end', cleanup);\n    processor.on('close', cleanup);\n\n    /* If the 'end' option is not supplied, dest.end() will be\n     * called when the 'end' or 'close' events are received.\n     * Only dest.end() once. */\n    if (!dest._isStdio && settings.end !== false) {\n      processor.on('end', onend);\n    }\n\n    dest.on('error', onerror);\n    dest.on('close', cleanup);\n\n    dest.emit('pipe', processor);\n\n    return dest;\n  }\n\n  /* Data management. */\n  processor.data = data;\n\n  /* Lock. */\n  processor.abstract = abstract;\n\n  /* Plug-ins. */\n  processor.use = use;\n\n  /* Streaming. */\n  processor.writable = true;\n  processor.readable = true;\n  processor.write = write;\n  processor.end = end;\n  processor.pipe = pipe;\n\n  /* API. */\n  processor.parse = parse;\n  processor.stringify = stringify;\n  processor.run = run;\n  processor.process = process;\n\n  /* Expose. */\n  return processor;\n}\n\n/**\n * Check if `node` is a Unist node.\n *\n * @param {*} node - Value.\n * @return {boolean} - Whether `node` is a Unist node.\n */\nfunction isNode(node) {\n  return node && typeof node.type === 'string' && node.type.length !== 0;\n}\n\n/**\n * Check if `file` is a VFile.\n *\n * @param {*} file - Value.\n * @return {boolean} - Whether `file` is a VFile.\n */\nfunction isFile(file) {\n  return file && typeof file.contents === 'string';\n}\n\n/**\n * Check if `fn` is a function.\n *\n * @param {*} fn - Value.\n * @return {boolean} - Whether `fn` is a function.\n */\nfunction isFunction(fn) {\n  return typeof fn === 'function';\n}\n\n/**\n * Check if `compiler` is a Compiler.\n *\n * @param {*} compiler - Value.\n * @return {boolean} - Whether `compiler` is a Compiler.\n */\nfunction isCompiler(compiler) {\n  return isFunction(compiler) && compiler.prototype && isFunction(compiler.prototype.compile);\n}\n\n/**\n * Check if `parser` is a Parser.\n *\n * @param {*} parser - Value.\n * @return {boolean} - Whether `parser` is a Parser.\n */\nfunction isParser(parser) {\n  return isFunction(parser) && parser.prototype && isFunction(parser.prototype.parse);\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n","'use strict';\n\nvar bind = require('function-bind');\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n","'use strict';\n\nvar implementation = require('./implementation');\n\nmodule.exports = Function.prototype.bind || implementation;\n","'use strict';\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","'use strict'\n\nmodule.exports = bail\n\nfunction bail(err) {\n  if (err) {\n    throw err\n  }\n}\n","/**\n * @author Titus Wormer\n * @copyright 2015 Titus Wormer\n * @license MIT\n * @module vfile\n * @fileoverview Virtual file format to attach additional\n *   information related to processed input.  Similar to\n *   `wearefractal/vinyl`.  Additionally, `VFile` can be\n *   passed directly to ESLint formatters to visualise\n *   warnings and errors relating to a file.\n * @example\n *   var VFile = require('vfile');\n *\n *   var file = new VFile({\n *     'directory': '~',\n *     'filename': 'example',\n *     'extension': 'txt',\n *     'contents': 'Foo *bar* baz'\n *   });\n *\n *   file.toString(); // 'Foo *bar* baz'\n *   file.filePath(); // '~/example.txt'\n *\n *   file.move({'extension': 'md'});\n *   file.filePath(); // '~/example.md'\n *\n *   file.warn('Something went wrong', {'line': 2, 'column': 3});\n *   // { [~/example.md:2:3: Something went wrong]\n *   //   name: '~/example.md:2:3',\n *   //   file: '~/example.md',\n *   //   reason: 'Something went wrong',\n *   //   line: 2,\n *   //   column: 3,\n *   //   fatal: false }\n */\n\n'use strict';\n\n/* eslint-env commonjs */\n\nvar proto;\n\nvar SEPARATOR = '/';\n\ntry {\n    SEPARATOR = require('pa' + 'th').sep;\n} catch (e) { /* empty */ }\n\n/**\n * Construct a new file message.\n *\n * Note: We cannot invoke `Error` on the created context,\n * as that adds readonly `line` and `column` attributes on\n * Safari 9, thus throwing and failing the data.\n *\n * @example\n *   var message = new VFileMessage('Whoops!');\n *\n *   message instanceof Error // true\n *\n * @constructor\n * @class {VFileMessage}\n * @param {string} reason - Reason for messaging.\n * @property {boolean} [fatal=null] - Whether the message\n *   is fatal.\n * @property {string} [name=''] - File-name and positional\n *   information.\n * @property {string} [file=''] - File-path.\n * @property {string} [reason=''] - Reason for messaging.\n * @property {number} [line=null] - Start of message.\n * @property {number} [column=null] - Start of message.\n * @property {Position|Location} [location=null] - Place of\n *   message.\n * @property {string} [stack] - Stack-trace of warning.\n */\nfunction VFileMessage(reason) {\n    this.message = reason;\n}\n\n/**\n * Inherit from `Error#`.\n */\nfunction VFileMessagePrototype() {}\n\nVFileMessagePrototype.prototype = Error.prototype;\n\nproto = new VFileMessagePrototype();\n\nVFileMessage.prototype = proto;\n\n/*\n * Expose defaults.\n */\n\nproto.file = proto.name = proto.reason = proto.message = proto.stack = '';\nproto.fatal = proto.column = proto.line = null;\n\n/**\n * File-related message with location information.\n *\n * @typedef {Error} VFileMessage\n * @property {string} name - (Starting) location of the\n *   message, preceded by its file-path when available,\n *   and joined by `:`. Used internally by the native\n *   `Error#toString()`.\n * @property {string} file - File-path.\n * @property {string} reason - Reason for message.\n * @property {number?} line - Line of message, when\n *   available.\n * @property {number?} column - Column of message, when\n *   available.\n * @property {string?} stack - Stack of message, when\n *   available.\n * @property {boolean?} fatal - Whether the associated file\n *   is still processable.\n */\n\n/**\n * Stringify a position.\n *\n * @example\n *   stringify({'line': 1, 'column': 3}) // '1:3'\n *   stringify({'line': 1}) // '1:1'\n *   stringify({'column': 3}) // '1:3'\n *   stringify() // '1:1'\n *\n * @private\n * @param {Object?} [position] - Single position, like\n *   those available at `node.position.start`.\n * @return {string} - Compiled location.\n */\nfunction stringify(position) {\n    if (!position) {\n        position = {};\n    }\n\n    return (position.line || 1) + ':' + (position.column || 1);\n}\n\n/**\n * ESLint's formatter API expects `filePath` to be a\n * string.  This hack supports invocation as well as\n * implicit coercion.\n *\n * @example\n *   var file = new VFile({\n *     'filename': 'example',\n *     'extension': 'txt'\n *   });\n *\n *   filePath = filePathFactory(file);\n *\n *   String(filePath); // 'example.txt'\n *   filePath(); // 'example.txt'\n *\n * @private\n * @param {VFile} file - Virtual file.\n * @return {Function} - `filePath` getter.\n */\nfunction filePathFactory(file) {\n    /**\n     * Get the filename, with extension and directory, if applicable.\n     *\n     * @example\n     *   var file = new VFile({\n     *     'directory': '~',\n     *     'filename': 'example',\n     *     'extension': 'txt'\n     *   });\n     *\n     *   String(file.filePath); // ~/example.txt\n     *   file.filePath() // ~/example.txt\n     *\n     * @memberof {VFile}\n     * @property {Function} toString - Itself. ESLint's\n     *   formatter API expects `filePath` to be `string`.\n     *   This hack supports invocation as well as implicit\n     *   coercion.\n     * @return {string} - If the `vFile` has a `filename`,\n     *   it will be prefixed with the directory (slashed),\n     *   if applicable, and suffixed with the (dotted)\n     *   extension (if applicable).  Otherwise, an empty\n     *   string is returned.\n     */\n    function filePath() {\n        var directory = file.directory;\n        var separator;\n\n        if (file.filename || file.extension) {\n            separator = directory.charAt(directory.length - 1);\n\n            if (separator === '/' || separator === '\\\\') {\n                directory = directory.slice(0, -1);\n            }\n\n            if (directory === '.') {\n                directory = '';\n            }\n\n            return (directory ? directory + SEPARATOR : '') +\n                file.filename +\n                (file.extension ? '.' + file.extension : '');\n        }\n\n        return '';\n    }\n\n    filePath.toString = filePath;\n\n    return filePath;\n}\n\n/**\n* Get the filename with extantion.\n*\n* @example\n*   var file = new VFile({\n*     'directory': '~/foo/bar'\n*     'filename': 'example',\n*     'extension': 'txt'\n*   });\n*\n*   file.basename() // example.txt\n*\n* @memberof {VFile}\n* @return {string} - name of file with extantion.\n*/\nfunction basename() {\n    var self = this;\n    var extension = self.extension;\n\n    if (self.filename || extension) {\n        return self.filename + (extension ? '.' + extension : '');\n    }\n\n    return '';\n}\n\n/**\n * Construct a new file.\n *\n * @example\n *   var file = new VFile({\n *     'directory': '~',\n *     'filename': 'example',\n *     'extension': 'txt',\n *     'contents': 'Foo *bar* baz'\n *   });\n *\n *   file === VFile(file) // true\n *   file === new VFile(file) // true\n *   VFile('foo') instanceof VFile // true\n *\n * @constructor\n * @class {VFile}\n * @param {Object|VFile|string} [options] - either an\n *   options object, or the value of `contents` (both\n *   optional).  When a `file` is passed in, it's\n *   immediately returned.\n * @property {string} [contents=''] - Content of file.\n * @property {string} [directory=''] - Path to parent\n *   directory.\n * @property {string} [filename=''] - Filename.\n *   A file-path can still be generated when no filename\n *   exists.\n * @property {string} [extension=''] - Extension.\n *   A file-path can still be generated when no extension\n *   exists.\n * @property {boolean?} quiet - Whether an error created by\n *   `VFile#fail()` is returned (when truthy) or thrown\n *   (when falsey). Ensure all `messages` associated with\n *   a file are handled properly when setting this to\n *   `true`.\n * @property {Array.<VFileMessage>} messages - List of associated\n *   messages.\n */\nfunction VFile(options) {\n    var self = this;\n\n    /*\n     * No `new` operator.\n     */\n\n    if (!(self instanceof VFile)) {\n        return new VFile(options);\n    }\n\n    /*\n     * Given file.\n     */\n\n    if (\n        options &&\n        typeof options.message === 'function' &&\n        typeof options.hasFailed === 'function'\n    ) {\n        return options;\n    }\n\n    if (!options) {\n        options = {};\n    } else if (typeof options === 'string') {\n        options = {\n            'contents': options\n        };\n    }\n\n    self.contents = options.contents || '';\n\n    self.messages = [];\n\n    /*\n     * Make sure eslints formatters stringify `filePath`\n     * properly.\n     */\n\n    self.filePath = filePathFactory(self);\n\n    self.history = [];\n\n    self.move({\n        'filename': options.filename,\n        'directory': options.directory,\n        'extension': options.extension\n    });\n}\n\n/**\n * Get the value of the file.\n *\n * @example\n *   var vFile = new VFile('Foo');\n *   String(vFile); // 'Foo'\n *\n * @this {VFile}\n * @memberof {VFile}\n * @return {string} - value at the `contents` property\n *   in context.\n */\nfunction toString() {\n    return this.contents;\n}\n\n/**\n * Move a file by passing a new directory, filename,\n * and extension.  When these are not given, the default\n * values are kept.\n *\n * @example\n *   var file = new VFile({\n *     'directory': '~',\n *     'filename': 'example',\n *     'extension': 'txt',\n *     'contents': 'Foo *bar* baz'\n *   });\n *\n *   file.move({'directory': '/var/www'});\n *   file.filePath(); // '/var/www/example.txt'\n *\n *   file.move({'extension': 'md'});\n *   file.filePath(); // '/var/www/example.md'\n *\n * @this {VFile}\n * @memberof {VFile}\n * @param {Object?} [options] - Configuration.\n * @return {VFile} - Context object.\n */\nfunction move(options) {\n    var self = this;\n    var before = self.filePath();\n    var after;\n\n    if (!options) {\n        options = {};\n    }\n\n    self.directory = options.directory || self.directory || '';\n    self.filename = options.filename || self.filename || '';\n    self.extension = options.extension || self.extension || '';\n\n    after = self.filePath();\n\n    if (after && before !== after) {\n        self.history.push(after);\n    }\n\n    return self;\n}\n\n/**\n * Create a message with `reason` at `position`.\n * When an error is passed in as `reason`, copies the\n * stack.  This does not add a message to `messages`.\n *\n * @example\n *   var file = new VFile();\n *\n *   file.message('Something went wrong');\n *   // { [1:1: Something went wrong]\n *   //   name: '1:1',\n *   //   file: '',\n *   //   reason: 'Something went wrong',\n *   //   line: null,\n *   //   column: null }\n *\n * @this {VFile}\n * @memberof {VFile}\n * @param {string|Error} reason - Reason for message.\n * @param {Node|Location|Position} [position] - Location\n *   of message in file.\n * @param {string} [ruleId] - Category of warning.\n * @return {VFileMessage} - File-related message with\n *   location information.\n */\nfunction message(reason, position, ruleId) {\n    var filePath = this.filePath();\n    var range;\n    var err;\n    var location = {\n        'start': {\n            'line': null,\n            'column': null\n        },\n        'end': {\n            'line': null,\n            'column': null\n        }\n    };\n\n    /*\n     * Node / location / position.\n     */\n\n    if (position && position.position) {\n        position = position.position;\n    }\n\n    if (position && position.start) {\n        range = stringify(position.start) + '-' + stringify(position.end);\n        location = position;\n        position = position.start;\n    } else {\n        range = stringify(position);\n\n        if (position) {\n            location.start = position;\n            location.end.line = null;\n            location.end.column = null;\n        }\n    }\n\n    err = new VFileMessage(reason.message || reason);\n\n    err.name = (filePath ? filePath + ':' : '') + range;\n    err.file = filePath;\n    err.reason = reason.message || reason;\n    err.line = position ? position.line : null;\n    err.column = position ? position.column : null;\n    err.location = location;\n    err.ruleId = ruleId || null;\n\n    if (reason.stack) {\n        err.stack = reason.stack;\n    }\n\n    return err;\n}\n\n/**\n * Warn. Creates a non-fatal message (see `VFile#message()`),\n * and adds it to the file's `messages` list.\n *\n * @example\n *   var file = new VFile();\n *\n *   file.warn('Something went wrong');\n *   // { [1:1: Something went wrong]\n *   //   name: '1:1',\n *   //   file: '',\n *   //   reason: 'Something went wrong',\n *   //   line: null,\n *   //   column: null,\n *   //   fatal: false }\n *\n * @see VFile#message\n * @this {VFile}\n * @memberof {VFile}\n */\nfunction warn() {\n    var err = this.message.apply(this, arguments);\n\n    err.fatal = false;\n\n    this.messages.push(err);\n\n    return err;\n}\n\n/**\n * Fail. Creates a fatal message (see `VFile#message()`),\n * sets `fatal: true`, adds it to the file's\n * `messages` list.\n *\n * If `quiet` is not `true`, throws the error.\n *\n * @example\n *   var file = new VFile();\n *\n *   file.fail('Something went wrong');\n *   // 1:1: Something went wrong\n *   //     at VFile.exception (vfile/index.js:296:11)\n *   //     at VFile.fail (vfile/index.js:360:20)\n *   //     at repl:1:6\n *\n *   file.quiet = true;\n *   file.fail('Something went wrong');\n *   // { [1:1: Something went wrong]\n *   //   name: '1:1',\n *   //   file: '',\n *   //   reason: 'Something went wrong',\n *   //   line: null,\n *   //   column: null,\n *   //   fatal: true }\n *\n * @this {VFile}\n * @memberof {VFile}\n * @throws {VFileMessage} - When not `quiet: true`.\n * @param {string|Error} reason - Reason for failure.\n * @param {Node|Location|Position} [position] - Place\n *   of failure in file.\n * @return {VFileMessage} - Unless thrown, of course.\n */\nfunction fail(reason, position) {\n    var err = this.message(reason, position);\n\n    err.fatal = true;\n\n    this.messages.push(err);\n\n    if (!this.quiet) {\n        throw err;\n    }\n\n    return err;\n}\n\n/**\n * Check if a fatal message occurred making the file no\n * longer processable.\n *\n * @example\n *   var file = new VFile();\n *   file.quiet = true;\n *\n *   file.hasFailed(); // false\n *\n *   file.fail('Something went wrong');\n *   file.hasFailed(); // true\n *\n * @this {VFile}\n * @memberof {VFile}\n * @return {boolean} - `true` if at least one of file's\n *   `messages` has a `fatal` property set to `true`\n */\nfunction hasFailed() {\n    var messages = this.messages;\n    var index = -1;\n    var length = messages.length;\n\n    while (++index < length) {\n        if (messages[index].fatal) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Access metadata.\n *\n * @example\n *   var file = new VFile('Foo');\n *\n *   file.namespace('foo').bar = 'baz';\n *\n *   console.log(file.namespace('foo').bar) // 'baz';\n *\n * @this {VFile}\n * @memberof {VFile}\n * @param {string} key - Namespace key.\n * @return {Object} - Private space.\n */\nfunction namespace(key) {\n    var self = this;\n    var space = self.data;\n\n    if (!space) {\n        space = self.data = {};\n    }\n\n    if (!space[key]) {\n        space[key] = {};\n    }\n\n    return space[key];\n}\n\n/*\n * Methods.\n */\n\nproto = VFile.prototype;\n\nproto.basename = basename;\nproto.move = move;\nproto.toString = toString;\nproto.message = message;\nproto.warn = warn;\nproto.fail = fail;\nproto.hasFailed = hasFailed;\nproto.namespace = namespace;\n\n/*\n * Expose.\n */\n\nmodule.exports = VFile;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n","'use strict'\n\nvar wrap = require('./wrap.js')\n\nmodule.exports = trough\n\ntrough.wrap = wrap\n\nvar slice = [].slice\n\n/* Create new middleware. */\nfunction trough() {\n  var fns = []\n  var middleware = {}\n\n  middleware.run = run\n  middleware.use = use\n\n  return middleware\n\n  /* Run `fns`.  Last argument must be\n   * a completion handler. */\n  function run() {\n    var index = -1\n    var input = slice.call(arguments, 0, -1)\n    var done = arguments[arguments.length - 1]\n\n    if (typeof done !== 'function') {\n      throw new Error('Expected function as last argument, not ' + done)\n    }\n\n    next.apply(null, [null].concat(input))\n\n    /* Run the next `fn`, if any. */\n    function next(err) {\n      var fn = fns[++index]\n      var params = slice.call(arguments, 0)\n      var values = params.slice(1)\n      var length = input.length\n      var pos = -1\n\n      if (err) {\n        done(err)\n        return\n      }\n\n      /* Copy non-nully input into values. */\n      while (++pos < length) {\n        if (values[pos] === null || values[pos] === undefined) {\n          values[pos] = input[pos]\n        }\n      }\n\n      input = values\n\n      /* Next or done. */\n      if (fn) {\n        wrap(fn, next).apply(null, input)\n      } else {\n        done.apply(null, [null].concat(input))\n      }\n    }\n  }\n\n  /* Add `fn` to the list. */\n  function use(fn) {\n    if (typeof fn !== 'function') {\n      throw new Error('Expected `fn` to be a function, not ' + fn)\n    }\n\n    fns.push(fn)\n\n    return middleware\n  }\n}\n","'use strict'\n\nvar slice = [].slice\n\nmodule.exports = wrap\n\n/* Wrap `fn`.  Can be sync or async; return a promise,\n * receive a completion handler, return new values and\n * errors. */\nfunction wrap(fn, callback) {\n  var invoked\n\n  return wrapped\n\n  function wrapped() {\n    var params = slice.call(arguments, 0)\n    var callback = fn.length > params.length\n    var result\n\n    if (callback) {\n      params.push(done)\n    }\n\n    try {\n      result = fn.apply(null, params)\n    } catch (err) {\n      /* Well, this is quite the pickle.  `fn` received\n       * a callback and invoked it (thus continuing the\n       * pipeline), but later also threw an error.\n       * Were not about to restart the pipeline again,\n       * so the only thing left to do is to throw the\n       * thing instea. */\n      if (callback && invoked) {\n        throw err\n      }\n\n      return done(err)\n    }\n\n    if (!callback) {\n      if (result && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  /* Invoke `next`, only once. */\n  function done() {\n    if (!invoked) {\n      invoked = true\n\n      callback.apply(null, arguments)\n    }\n  }\n\n  /* Invoke `done` with one value.\n   * Tracks if an error is passed, too. */\n  function then(value) {\n    done(null, value)\n  }\n}\n","/**\n * @author Titus Wormer\n * @copyright 2015-2016 Titus Wormer\n * @license MIT\n * @module remark:parse\n * @fileoverview Markdown parser.\n */\n\n'use strict';\n\n/* eslint-env commonjs */\n\n/* Dependencies. */\nvar unherit = require('unherit');\nvar Parser = require('./lib/parser.js');\n\n/**\n * Attacher.\n *\n * @param {unified} processor - Unified processor.\n */\nfunction parse(processor) {\n    processor.Parser = unherit(Parser);\n}\n\n/* Patch `Parser`. */\nparse.Parser = Parser;\n\n/* Expose */\nmodule.exports = parse;\n","'use strict'\n\nvar xtend = require('xtend')\nvar inherits = require('inherits')\n\nmodule.exports = unherit\n\n/* Create a custom constructor which can be modified\n * without affecting the original class. */\nfunction unherit(Super) {\n  var result\n  var key\n  var value\n\n  inherits(Of, Super)\n  inherits(From, Of)\n\n  /* Clone values. */\n  result = Of.prototype\n\n  for (key in result) {\n    value = result[key]\n\n    if (value && typeof value === 'object') {\n      result[key] = 'concat' in value ? value.concat() : xtend(value)\n    }\n  }\n\n  return Of\n\n  /* Constructor accepting a single argument,\n   * which itself is an `arguments` object. */\n  function From(parameters) {\n    return Super.apply(this, parameters)\n  }\n\n  /* Constructor accepting variadic arguments. */\n  function Of() {\n    if (!(this instanceof Of)) {\n      return new From(arguments)\n    }\n\n    return Super.apply(this, arguments)\n  }\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","/**\n * @author Titus Wormer\n * @copyright 2015-2016 Titus Wormer\n * @license MIT\n * @module remark:parser\n * @fileoverview Markdown parser.\n */\n\n'use strict';\n\n/* eslint-env commonjs */\n\n/*\n * Dependencies.\n */\n\nvar decode = require('parse-entities');\nvar repeat = require('repeat-string');\nvar trim = require('trim');\nvar trimTrailingLines = require('trim-trailing-lines');\nvar extend = require('extend');\nvar vfileLocation = require('vfile-location');\nvar removePosition = require('unist-util-remove-position');\nvar collapseWhiteSpace = require('collapse-white-space');\nvar defaultOptions = require('./defaults.js');\nvar escapes = require('./escapes.json');\nvar blockElements = require('./block-elements.json');\n\n/*\n * Methods.\n */\n\nvar has = {}.hasOwnProperty;\n\n/*\n * Numeric constants.\n */\n\nvar SPACE_SIZE = 1;\nvar TAB_SIZE = 4;\nvar CODE_INDENT_LENGTH = 4;\nvar MIN_FENCE_COUNT = 3;\nvar MAX_ATX_COUNT = 6;\nvar MAX_LINE_HEADING_INDENT = 3;\nvar THEMATIC_BREAK_MARKER_COUNT = 3;\nvar MIN_CLOSING_HTML_NEWLINE_COUNT = 2;\nvar MIN_BREAK_LENGTH = 2;\nvar MIN_TABLE_COLUMNS = 2;\nvar MIN_TABLE_ROWS = 2;\n\n/*\n * Error messages.\n */\n\nvar ERR_INFINITE_LOOP = 'Infinite loop';\nvar ERR_MISSING_LOCATOR = 'Missing locator: ';\nvar ERR_INCORRECTLY_EATEN = 'Incorrectly eaten value: please report this ' +\n    'warning on http://git.io/vg5Ft';\n\n/*\n * Expressions.\n */\n\nvar EXPRESSION_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar EXPRESSION_PEDANTIC_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar EXPRESSION_INITIAL_INDENT = /^( {1,4}|\\t)?/gm;\nvar EXPRESSION_INITIAL_TAB = /^( {4}|\\t)?/gm;\nvar EXPRESSION_HTML_LINK_OPEN = /^<a /i;\nvar EXPRESSION_HTML_LINK_CLOSE = /^<\\/a>/i;\nvar EXPRESSION_LOOSE_LIST_ITEM = /\\n\\n(?!\\s*$)/;\nvar EXPRESSION_TASK_ITEM = /^\\[([\\ \\t]|x|X)\\][\\ \\t]/;\nvar EXPRESSION_LINE_BREAKS = /\\r\\n|\\r/g;\n\n/*\n * Characters.\n */\n\nvar C_BACKSLASH = '\\\\';\nvar C_UNDERSCORE = '_';\nvar C_ASTERISK = '*';\nvar C_TICK = '`';\nvar C_AT_SIGN = '@';\nvar C_HASH = '#';\nvar C_PLUS = '+';\nvar C_DASH = '-';\nvar C_DOT = '.';\nvar C_PIPE = '|';\nvar C_DOUBLE_QUOTE = '\"';\nvar C_SINGLE_QUOTE = '\\'';\nvar C_COMMA = ',';\nvar C_SLASH = '/';\nvar C_COLON = ':';\nvar C_SEMI_COLON = ';';\nvar C_QUESTION_MARK = '?';\nvar C_CARET = '^';\nvar C_EQUALS = '=';\nvar C_EXCLAMATION_MARK = '!';\nvar C_TILDE = '~';\nvar C_LT = '<';\nvar C_GT = '>';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_PAREN_OPEN = '(';\nvar C_PAREN_CLOSE = ')';\nvar C_SPACE = ' ';\nvar C_FORM_FEED = '\\f';\nvar C_NEWLINE = '\\n';\nvar C_CARRIAGE_RETURN = '\\r';\nvar C_TAB = '\\t';\nvar C_VERTICAL_TAB = '\\v';\nvar C_NO_BREAK_SPACE = '\\u00a0';\nvar C_OGHAM_SPACE = '\\u1680';\nvar C_MONGOLIAN_VOWEL_SEPARATOR = '\\u180e';\nvar C_EN_QUAD = '\\u2000';\nvar C_EM_QUAD = '\\u2001';\nvar C_EN_SPACE = '\\u2002';\nvar C_EM_SPACE = '\\u2003';\nvar C_THREE_PER_EM_SPACE = '\\u2004';\nvar C_FOUR_PER_EM_SPACE = '\\u2005';\nvar C_SIX_PER_EM_SPACE = '\\u2006';\nvar C_FIGURE_SPACE = '\\u2007';\nvar C_PUNCTUATION_SPACE = '\\u2008';\nvar C_THIN_SPACE = '\\u2009';\nvar C_HAIR_SPACE = '\\u200a';\nvar C_LINE_SEPARATOR = '\\u2028';\nvar C_PARAGRAPH_SEPARATOR = '\\u2029';\nvar C_NARROW_NO_BREAK_SPACE = '\\u202f';\nvar C_IDEOGRAPHIC_SPACE = '\\u3000';\nvar C_ZERO_WIDTH_NO_BREAK_SPACE = '\\ufeff';\nvar C_X_LOWER = 'x';\n\n/*\n * Character codes.\n */\n\nvar CC_A_LOWER = 'a'.charCodeAt(0);\nvar CC_A_UPPER = 'A'.charCodeAt(0);\nvar CC_Z_LOWER = 'z'.charCodeAt(0);\nvar CC_Z_UPPER = 'Z'.charCodeAt(0);\nvar CC_0 = '0'.charCodeAt(0);\nvar CC_9 = '9'.charCodeAt(0);\n\n/*\n * Protocols.\n */\n\nvar HTTP_PROTOCOL = 'http://';\nvar HTTPS_PROTOCOL = 'https://';\nvar MAILTO_PROTOCOL = 'mailto:';\n\nvar PROTOCOLS = [\n    HTTP_PROTOCOL,\n    HTTPS_PROTOCOL,\n    MAILTO_PROTOCOL\n];\n\nvar PROTOCOLS_LENGTH = PROTOCOLS.length;\n\n/*\n * Textual constants.\n */\n\nvar YAML_FENCE = repeat(C_DASH, 3);\nvar CODE_INDENT = repeat(C_SPACE, CODE_INDENT_LENGTH);\nvar EMPTY = '';\nvar BLOCK = 'block';\nvar INLINE = 'inline';\nvar COMMENT_START = '<!--';\nvar COMMENT_END = '-->';\nvar CDATA_START = '<![CDATA[';\nvar CDATA_END = ']]>';\nvar COMMENT_END_CHAR = COMMENT_END.charAt(0);\nvar CDATA_END_CHAR = CDATA_END.charAt(0);\nvar COMMENT_START_LENGTH = COMMENT_START.length;\nvar COMMENT_END_LENGTH = COMMENT_END.length;\nvar CDATA_START_LENGTH = CDATA_START.length;\nvar CDATA_END_LENGTH = CDATA_END.length;\n\n/*\n * Node types.\n */\n\nvar T_THEMATIC_BREAK = 'thematicBreak';\nvar T_HTML = 'html';\nvar T_YAML = 'yaml';\nvar T_TABLE = 'table';\nvar T_TABLE_CELL = 'tableCell';\nvar T_TABLE_HEADER = 'tableRow';\nvar T_TABLE_ROW = 'tableRow';\nvar T_PARAGRAPH = 'paragraph';\nvar T_TEXT = 'text';\nvar T_CODE = 'code';\nvar T_LIST = 'list';\nvar T_LIST_ITEM = 'listItem';\nvar T_DEFINITION = 'definition';\nvar T_FOOTNOTE_DEFINITION = 'footnoteDefinition';\nvar T_HEADING = 'heading';\nvar T_BLOCKQUOTE = 'blockquote';\nvar T_LINK = 'link';\nvar T_IMAGE = 'image';\nvar T_FOOTNOTE = 'footnote';\nvar T_STRONG = 'strong';\nvar T_EMPHASIS = 'emphasis';\nvar T_DELETE = 'delete';\nvar T_INLINE_CODE = 'inlineCode';\nvar T_BREAK = 'break';\nvar T_ROOT = 'root';\n\n/*\n * Available table alignments.\n */\n\nvar TABLE_ALIGN_LEFT = 'left';\nvar TABLE_ALIGN_CENTER = 'center';\nvar TABLE_ALIGN_RIGHT = 'right';\nvar TABLE_ALIGN_NONE = null;\n\n/*\n * Available reference types.\n */\n\nvar REFERENCE_TYPE_SHORTCUT = 'shortcut';\nvar REFERENCE_TYPE_COLLAPSED = 'collapsed';\nvar REFERENCE_TYPE_FULL = 'full';\n\n/*\n * A map of characters, and their column length,\n * which can be used as indentation.\n */\n\nvar INDENTATION_CHARACTERS = {};\n\nINDENTATION_CHARACTERS[C_SPACE] = SPACE_SIZE;\nINDENTATION_CHARACTERS[C_TAB] = TAB_SIZE;\n\n/*\n * A map of characters, which can be used to mark emphasis.\n */\n\nvar EMPHASIS_MARKERS = {};\n\nEMPHASIS_MARKERS[C_ASTERISK] = true;\nEMPHASIS_MARKERS[C_UNDERSCORE] = true;\n\n/*\n * A map of characters, which can be used to mark rules.\n */\n\nvar RULE_MARKERS = {};\n\nRULE_MARKERS[C_ASTERISK] = true;\nRULE_MARKERS[C_UNDERSCORE] = true;\nRULE_MARKERS[C_DASH] = true;\n\n/*\n * A map of characters which can be used to mark\n * list-items.\n */\n\nvar LIST_UNORDERED_MARKERS = {};\n\nLIST_UNORDERED_MARKERS[C_ASTERISK] = true;\nLIST_UNORDERED_MARKERS[C_PLUS] = true;\nLIST_UNORDERED_MARKERS[C_DASH] = true;\n\n/*\n * A map of characters which can be used to mark\n * list-items after a digit.\n */\n\nvar LIST_ORDERED_MARKERS = {};\n\nLIST_ORDERED_MARKERS[C_DOT] = true;\n\n/*\n * A map of characters which can be used to mark\n * list-items after a digit.\n */\n\nvar LIST_ORDERED_COMMONMARK_MARKERS = {};\n\nLIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;\nLIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;\n\n/*\n * A map of characters, which can be used to mark link\n * and image titles.\n */\n\nvar LINK_MARKERS = {};\n\nLINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nLINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\n\n/*\n * A map of characters, which can be used to mark link\n * and image titles in commonmark-mode.\n */\n\nvar COMMONMARK_LINK_MARKERS = {};\n\nCOMMONMARK_LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_PAREN_OPEN] = C_PAREN_CLOSE;\n\n/*\n * A map of characters which can be used to mark setext\n * headers, mapping to their corresponding depth.\n */\n\nvar SETEXT_MARKERS = {};\n\nSETEXT_MARKERS[C_EQUALS] = 1;\nSETEXT_MARKERS[C_DASH] = 2;\n\n/*\n * A map of two functions which can create list items.\n */\n\nvar LIST_ITEM_MAP = {};\n\nLIST_ITEM_MAP.true = renderPedanticListItem;\nLIST_ITEM_MAP.false = renderNormalListItem;\n\n/**\n * Check whether `character` is alphabetic.\n *\n * @param {string} character - Single character to check.\n * @return {boolean} - Whether `character` is alphabetic.\n */\nfunction isAlphabetic(character) {\n    var code = character.charCodeAt(0);\n\n    return (code >= CC_A_LOWER && code <= CC_Z_LOWER) ||\n        (code >= CC_A_UPPER && code <= CC_Z_UPPER);\n}\n\n/**\n * Check whether `character` is numeric.\n *\n * @param {string} character - Single character to check.\n * @return {boolean} - Whether `character` is numeric.\n */\nfunction isNumeric(character) {\n    var code = character.charCodeAt(0);\n\n    return code >= CC_0 && code <= CC_9;\n}\n\n/**\n * Check whether `character` is a word character.\n *\n * @param {string} character - Single character to check.\n * @return {boolean} - Whether `character` is a word\n *   character.\n */\nfunction isWordCharacter(character) {\n    return character === C_UNDERSCORE ||\n        isAlphabetic(character) ||\n        isNumeric(character);\n}\n\n/**\n * Check whether `character` is white-space.\n *\n * @param {string} character - Single character to check.\n * @return {boolean} - Whether `character` is white-space.\n */\nfunction isWhiteSpace(character) {\n    return character === C_SPACE ||\n        character === C_FORM_FEED ||\n        character === C_NEWLINE ||\n        character === C_CARRIAGE_RETURN ||\n        character === C_TAB ||\n        character === C_VERTICAL_TAB ||\n        character === C_NO_BREAK_SPACE ||\n        character === C_OGHAM_SPACE ||\n        character === C_MONGOLIAN_VOWEL_SEPARATOR ||\n        character === C_EN_QUAD ||\n        character === C_EM_QUAD ||\n        character === C_EN_SPACE ||\n        character === C_EM_SPACE ||\n        character === C_THREE_PER_EM_SPACE ||\n        character === C_FOUR_PER_EM_SPACE ||\n        character === C_SIX_PER_EM_SPACE ||\n        character === C_FIGURE_SPACE ||\n        character === C_PUNCTUATION_SPACE ||\n        character === C_THIN_SPACE ||\n        character === C_HAIR_SPACE ||\n        character === C_LINE_SEPARATOR ||\n        character === C_PARAGRAPH_SEPARATOR ||\n        character === C_NARROW_NO_BREAK_SPACE ||\n        character === C_IDEOGRAPHIC_SPACE ||\n        character === C_ZERO_WIDTH_NO_BREAK_SPACE;\n}\n\n/**\n * Check whether `character` can be inside an unquoted\n * attribute value.\n *\n * @param {string} character - Single character to check.\n * @return {boolean} - Whether `character` can be inside\n *   an unquoted attribute value.\n */\nfunction isUnquotedAttributeCharacter(character) {\n    return character !== C_DOUBLE_QUOTE &&\n        character !== C_SINGLE_QUOTE &&\n        character !== C_EQUALS &&\n        character !== C_LT &&\n        character !== C_GT &&\n        character !== C_TICK;\n}\n\n/**\n * Check whether `character` can be inside a double-quoted\n * attribute value.\n *\n * @property {string} delimiter - Closing delimiter.\n * @param {string} character - Single character to check.\n * @return {boolean} - Whether `character` can be inside\n *   a double-quoted attribute value.\n */\nfunction isDoubleQuotedAttributeCharacter(character) {\n    return character !== C_DOUBLE_QUOTE;\n}\n\nisDoubleQuotedAttributeCharacter.delimiter = C_DOUBLE_QUOTE;\n\n/**\n * Check whether `character` can be inside a single-quoted\n * attribute value.\n *\n * @property {string} delimiter - Closing delimiter.\n * @param {string} character - Single character to check.\n * @return {boolean} - Whether `character` can be inside\n *   a single-quoted attribute value.\n */\nfunction isSingleQuotedAttributeCharacter(character) {\n    return character !== C_SINGLE_QUOTE;\n}\n\nisSingleQuotedAttributeCharacter.delimiter = C_SINGLE_QUOTE;\n\n/**\n * Check whether `character` can be inside an enclosed\n * URI.\n *\n * @property {string} delimiter - Closing delimiter.\n * @param {string} character - Character to test.\n * @return {boolean} - Whether `character` can be inside\n *   an enclosed URI.\n */\nfunction isEnclosedURLCharacter(character) {\n    return character !== C_GT &&\n        character !== C_BRACKET_OPEN &&\n        character !== C_BRACKET_CLOSE;\n}\n\nisEnclosedURLCharacter.delimiter = C_GT;\n\n/**\n * Check whether `character` can be inside an unclosed\n * URI.\n *\n * @param {string} character - Character to test.\n * @return {boolean} - Whether `character` can be inside\n *   an unclosed URI.\n */\nfunction isUnclosedURLCharacter(character) {\n    return character !== C_BRACKET_OPEN &&\n        character !== C_BRACKET_CLOSE &&\n        !isWhiteSpace(character);\n}\n\n/**\n * Normalize an identifier.  Collapses multiple white space\n * characters into a single space, and removes casing.\n *\n * @example\n *   normalizeIdentifier('FOO\\t bar'); // 'foo bar'\n *\n * @param {string} value - Content to normalize.\n * @return {string} - Normalized content.\n */\nfunction normalize(value) {\n    return collapseWhiteSpace(value).toLowerCase();\n}\n\n/**\n * Construct a state `toggler`: a function which inverses\n * `property` in context based on its current value.\n * The by `toggler` returned function restores that value.\n *\n * @example\n *   var context = {};\n *   var key = 'foo';\n *   var val = true;\n *   context[key] = val;\n *   context.enter = toggle(key, val);\n *   context[key]; // true\n *   var exit = context.enter();\n *   context[key]; // false\n *   var nested = context.enter();\n *   context[key]; // false\n *   nested();\n *   context[key]; // false\n *   exit();\n *   context[key]; // true\n *\n * @param {string} key - Property to toggle.\n * @param {boolean} state - It's default state.\n * @return {function(): function()} - Enter.\n */\nfunction toggle(key, state) {\n    /**\n     * Construct a toggler for the bound `key`.\n     *\n     * @return {Function} - Exit state.\n     */\n    function enter() {\n        var self = this;\n        var current = self[key];\n\n        self[key] = !state;\n\n        /**\n         * State canceler, cancels the state, if allowed.\n         */\n        function exit() {\n            self[key] = current;\n        }\n\n        return exit;\n    }\n\n    return enter;\n}\n\n/*\n * Define nodes of a type which can be merged.\n */\n\nvar MERGEABLE_NODES = {};\n\n/**\n * Check whether a node is mergeable with adjacent nodes.\n *\n * @param {Object} node - Node to check.\n * @return {boolean} - Whether `node` is mergable.\n */\nfunction mergeable(node) {\n    var start;\n    var end;\n\n    if (node.type !== 'text' || !node.position) {\n        return true;\n    }\n\n    start = node.position.start;\n    end = node.position.end;\n\n    /*\n     * Only merge nodes which occupy the same size as their\n     * `value`.\n     */\n\n    return start.line !== end.line ||\n        end.column - start.column === node.value.length;\n}\n\n/**\n * Merge two text nodes: `node` into `prev`.\n *\n * @param {Object} prev - Preceding sibling.\n * @param {Object} node - Following sibling.\n * @return {Object} - `prev`.\n */\nMERGEABLE_NODES.text = function (prev, node) {\n    prev.value += node.value;\n\n    return prev;\n};\n\n/**\n * Merge two blockquotes: `node` into `prev`, unless in\n * CommonMark mode.\n *\n * @param {Object} prev - Preceding sibling.\n * @param {Object} node - Following sibling.\n * @return {Object} - `prev`, or `node` in CommonMark mode.\n */\nMERGEABLE_NODES.blockquote = function (prev, node) {\n    if (this.options.commonmark) {\n        return node;\n    }\n\n    prev.children = prev.children.concat(node.children);\n\n    return prev;\n};\n\n/**\n * Factory to create an entity decoder.\n *\n * @param {Object} context - Context to attach to, e.g.,\n *   a parser.\n * @return {Function} - See `decode`.\n */\nfunction decodeFactory(context) {\n    /**\n     * Normalize `position` to add an `indent`.\n     *\n     * @param {Position} position - Reference\n     * @return {Position} - Augmented with `indent`.\n     */\n    function normalize(position) {\n        return {\n            'start': position,\n            'indent': context.getIndent(position.line)\n        };\n    }\n\n    /**\n     * Handle a warning.\n     *\n     * @this {VFile} - Virtual file.\n     * @param {string} reason - Reason for warning.\n     * @param {Position} position - Place of warning.\n     * @param {number} code - Code for warning.\n     */\n    function handleWarning(reason, position, code) {\n        if (code === 3) {\n            return;\n        }\n\n        context.file.warn(reason, position);\n    }\n\n    /**\n     * Decode `value` (at `position`) into text-nodes.\n     *\n     * @param {string} value - Value to parse.\n     * @param {Position} position - Position to start parsing at.\n     * @param {Function} handler - Node handler.\n     */\n    function decoder(value, position, handler) {\n        decode(value, {\n            'position': normalize(position),\n            'warning': handleWarning,\n            'text': handler,\n            'reference': handler,\n            'textContext': context,\n            'referenceContext': context\n        });\n    }\n\n    /**\n     * Decode `value` (at `position`) into a string.\n     *\n     * @param {string} value - Value to parse.\n     * @param {Position} position - Position to start\n     *   parsing at.\n     * @return {string} - Plain-text.\n     */\n    function decodeRaw(value, position) {\n        return decode(value, {\n            'position': normalize(position),\n            'warning': handleWarning\n        });\n    }\n\n    decoder.raw = decodeRaw;\n\n    return decoder;\n}\n\n/**\n * Factory to de-escape a value, based on a list at `key`\n * in `scope`.\n *\n * @example\n *   var scope = {escape: ['a']}\n *   var descape = descapeFactory(scope, 'escape');\n *\n * @param {Object} scope - List of escapable characters.\n * @param {string} key - Key in `map` at which the list\n *   exists.\n * @return {function(string): string} - Function which\n *   takes a value and returns its unescaped version.\n */\nfunction descapeFactory(scope, key) {\n    /**\n     * De-escape a string using the expression at `key`\n     * in `scope`.\n     *\n     * @example\n     *   var scope = {escape: ['a']}\n     *   var descape = descapeFactory(scope, 'escape');\n     *   descape('\\a \\b'); // 'a \\b'\n     *\n     * @param {string} value - Escaped string.\n     * @return {string} - Unescaped string.\n     */\n    function descape(value) {\n        var prev = 0;\n        var index = value.indexOf(C_BACKSLASH);\n        var escape = scope[key];\n        var queue = [];\n        var character;\n\n        while (index !== -1) {\n            queue.push(value.slice(prev, index));\n            prev = index + 1;\n            character = value.charAt(prev);\n\n            /*\n             * If the following character is not a valid escape,\n             * add the slash.\n             */\n\n            if (!character || escape.indexOf(character) === -1) {\n                queue.push(C_BACKSLASH);\n            }\n\n            index = value.indexOf(C_BACKSLASH, prev);\n        }\n\n        queue.push(value.slice(prev));\n\n        return queue.join(EMPTY);\n    }\n\n    return descape;\n}\n\n/**\n * Gets indentation information for a line.\n *\n * @example\n *   getIndent('  foo');\n *   // {indent: 2, stops: {1: 0, 2: 1}}\n *\n *   getIndent('\\tfoo');\n *   // {indent: 4, stops: {4: 0}}\n *\n *   getIndent('  \\tfoo');\n *   // {indent: 4, stops: {1: 0, 2: 1, 4: 2}}\n *\n *   getIndent('\\t  foo')\n *   // {indent: 6, stops: {4: 0, 5: 1, 6: 2}}\n *\n * @param {string} value - Indented line.\n * @return {Object} - Indetation information.\n */\nfunction getIndent(value) {\n    var index = 0;\n    var indent = 0;\n    var character = value.charAt(index);\n    var stops = {};\n    var size;\n\n    while (character in INDENTATION_CHARACTERS) {\n        size = INDENTATION_CHARACTERS[character];\n\n        indent += size;\n\n        if (size > 1) {\n            indent = Math.floor(indent / size) * size;\n        }\n\n        stops[indent] = index;\n\n        character = value.charAt(++index);\n    }\n\n    return {\n        'indent': indent,\n        'stops': stops\n    };\n}\n\n/**\n * Remove the minimum indent from every line in `value`.\n * Supports both tab, spaced, and mixed indentation (as\n * well as possible).\n *\n * @example\n *   removeIndentation('  foo'); // 'foo'\n *   removeIndentation('    foo', 2); // '  foo'\n *   removeIndentation('\\tfoo', 2); // '  foo'\n *   removeIndentation('  foo\\n bar'); // ' foo\\n bar'\n *\n * @param {string} value - Value to trim.\n * @param {number?} [maximum] - Maximum indentation\n *   to remove.\n * @return {string} - Unindented `value`.\n */\nfunction removeIndentation(value, maximum) {\n    var values = value.split(C_NEWLINE);\n    var position = values.length + 1;\n    var minIndent = Infinity;\n    var matrix = [];\n    var index;\n    var indentation;\n    var stops;\n    var padding;\n\n    values.unshift(repeat(C_SPACE, maximum) + C_EXCLAMATION_MARK);\n\n    while (position--) {\n        indentation = getIndent(values[position]);\n\n        matrix[position] = indentation.stops;\n\n        if (trim(values[position]).length === 0) {\n            continue;\n        }\n\n        if (indentation.indent) {\n            if (indentation.indent > 0 && indentation.indent < minIndent) {\n                minIndent = indentation.indent;\n            }\n        } else {\n            minIndent = Infinity;\n\n            break;\n        }\n    }\n\n    if (minIndent !== Infinity) {\n        position = values.length;\n\n        while (position--) {\n            stops = matrix[position];\n            index = minIndent;\n\n            while (index && !(index in stops)) {\n                index--;\n            }\n\n            if (\n                trim(values[position]).length !== 0 &&\n                minIndent &&\n                index !== minIndent\n            ) {\n                padding = C_TAB;\n            } else {\n                padding = EMPTY;\n            }\n\n            values[position] = padding + values[position].slice(\n                index in stops ? stops[index] + 1 : 0\n            );\n        }\n    }\n\n    values.shift();\n\n    return values.join(C_NEWLINE);\n}\n\n/**\n * Tokenise a line.\n *\n * @example\n *   tokenizeNewline(eat, '\\n\\n');\n *\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {boolean?} - `true` when matching.\n */\nfunction tokenizeNewline(eat, value, silent) {\n    var character = value.charAt(0);\n    var length;\n    var subvalue;\n    var queue;\n    var index;\n\n    if (character !== C_NEWLINE) {\n        return;\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n        return true;\n    }\n\n    index = 1;\n    length = value.length;\n    subvalue = C_NEWLINE;\n    queue = EMPTY;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (!isWhiteSpace(character)) {\n            break;\n        }\n\n        queue += character;\n\n        if (character === C_NEWLINE) {\n            subvalue += queue;\n            queue = EMPTY;\n        }\n\n        index++;\n    }\n\n    eat(subvalue);\n}\n\n/**\n * Tokenise an indented code block.\n *\n * @example\n *   tokenizeIndentedCode(eat, '\\tfoo');\n *\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `code` node.\n */\nfunction tokenizeIndentedCode(eat, value, silent) {\n    var self = this;\n    var index = -1;\n    var length = value.length;\n    var character;\n    var subvalue = EMPTY;\n    var content = EMPTY;\n    var subvalueQueue = EMPTY;\n    var contentQueue = EMPTY;\n    var blankQueue;\n    var indent;\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (indent) {\n            indent = false;\n\n            subvalue += subvalueQueue;\n            content += contentQueue;\n            subvalueQueue = contentQueue = EMPTY;\n\n            if (character === C_NEWLINE) {\n                subvalueQueue = contentQueue = character;\n            } else {\n                subvalue += character;\n                content += character;\n\n                while (++index < length) {\n                    character = value.charAt(index);\n\n                    if (!character || character === C_NEWLINE) {\n                        contentQueue = subvalueQueue = character;\n                        break;\n                    }\n\n                    subvalue += character;\n                    content += character;\n                }\n            }\n        } else if (\n            character === C_SPACE &&\n            value.charAt(index + 1) === C_SPACE &&\n            value.charAt(index + 2) === C_SPACE &&\n            value.charAt(index + 3) === C_SPACE\n        ) {\n            subvalueQueue += CODE_INDENT;\n            index += 3;\n            indent = true;\n        } else if (character === C_TAB) {\n            subvalueQueue += character;\n            indent = true;\n        } else {\n            blankQueue = EMPTY;\n\n            while (character === C_TAB || character === C_SPACE) {\n                blankQueue += character;\n                character = value.charAt(++index);\n            }\n\n            if (character !== C_NEWLINE) {\n                break;\n            }\n\n            subvalueQueue += blankQueue + character;\n            contentQueue += character;\n        }\n    }\n\n    if (content) {\n        if (silent) {\n            return true;\n        }\n\n        return eat(subvalue)(self.renderCodeBlock(content));\n    }\n}\n\n/**\n * Tokenise a fenced code block.\n *\n * @example\n *   tokenizeFencedCode(eat, '```js\\nfoo()\\n```');\n *\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `code` node.\n */\nfunction tokenizeFencedCode(eat, value, silent) {\n    var self = this;\n    var settings = self.options;\n    var length = value.length + 1;\n    var index = 0;\n    var subvalue = EMPTY;\n    var fenceCount;\n    var marker;\n    var character;\n    var flag;\n    var queue;\n    var content;\n    var exdentedContent;\n    var closing;\n    var exdentedClosing;\n    var indent;\n    var now;\n\n    if (!settings.gfm) {\n        return;\n    }\n\n    /*\n     * Eat initial spacing.\n     */\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_SPACE && character !== C_TAB) {\n            break;\n        }\n\n        subvalue += character;\n        index++;\n    }\n\n    indent = index; // TODO: CHECK.\n\n    /*\n     * Eat the fence.\n     */\n\n    character = value.charAt(index);\n\n    if (character !== C_TILDE && character !== C_TICK) {\n        return;\n    }\n\n    index++;\n    marker = character;\n    fenceCount = 1;\n    subvalue += character;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== marker) {\n            break;\n        }\n\n        subvalue += character;\n        fenceCount++;\n        index++;\n    }\n\n    if (fenceCount < MIN_FENCE_COUNT) {\n        return;\n    }\n\n    /*\n     * Eat spacing before flag.\n     */\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_SPACE && character !== C_TAB) {\n            break;\n        }\n\n        subvalue += character;\n        index++;\n    }\n\n    /*\n     * Eat flag.\n     */\n\n    flag = queue = EMPTY;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (\n            character === C_NEWLINE ||\n            character === C_TILDE ||\n            character === C_TICK\n        ) {\n            break;\n        }\n\n        if (character === C_SPACE || character === C_TAB) {\n            queue += character;\n        } else {\n            flag += queue + character;\n            queue = EMPTY;\n        }\n\n        index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character && character !== C_NEWLINE) {\n        return;\n    }\n\n    if (silent) {\n        return true;\n    }\n\n    now = eat.now();\n    now.column += subvalue.length;\n    now.offset += subvalue.length;\n\n    subvalue += flag;\n    flag = self.decode.raw(self.descape(flag), now);\n\n    if (queue) {\n        subvalue += queue;\n    }\n\n    queue = closing = exdentedClosing = content = exdentedContent = EMPTY;\n\n    /*\n     * Eat content.\n     */\n\n    while (index < length) {\n        character = value.charAt(index);\n        content += closing;\n        exdentedContent += exdentedClosing;\n        closing = exdentedClosing = EMPTY;\n\n        if (character !== C_NEWLINE) {\n            content += character;\n            exdentedClosing += character;\n            index++;\n            continue;\n        }\n\n        /*\n         * Add the newline to `subvalue` if its the first\n         * character. Otherwise, add it to the `closing`\n         * queue.\n         */\n\n        if (!content) {\n            subvalue += character;\n        } else {\n            closing += character;\n            exdentedClosing += character;\n        }\n\n        queue = EMPTY;\n        index++;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (character !== C_SPACE) {\n                break;\n            }\n\n            queue += character;\n            index++;\n        }\n\n        closing += queue;\n        exdentedClosing += queue.slice(indent);\n\n        if (queue.length >= CODE_INDENT_LENGTH) {\n            continue;\n        }\n\n        queue = EMPTY;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (character !== marker) {\n                break;\n            }\n\n            queue += character;\n            index++;\n        }\n\n        closing += queue;\n        exdentedClosing += queue;\n\n        if (queue.length < fenceCount) {\n            continue;\n        }\n\n        queue = EMPTY;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (character !== C_SPACE && character !== C_TAB) {\n                break;\n            }\n\n            closing += character;\n            exdentedClosing += character;\n            index++;\n        }\n\n        if (!character || character === C_NEWLINE) {\n            break;\n        }\n    }\n\n    subvalue += content + closing;\n\n    return eat(subvalue)(self.renderCodeBlock(exdentedContent, flag));\n}\n\n/**\n * Tokenise an ATX-style heading.\n *\n * @example\n *   tokenizeATXHeading(eat, ' # foo');\n *\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `heading` node.\n */\nfunction tokenizeATXHeading(eat, value, silent) {\n    var self = this;\n    var settings = self.options;\n    var length = value.length + 1;\n    var index = -1;\n    var now = eat.now();\n    var subvalue = EMPTY;\n    var content = EMPTY;\n    var character;\n    var queue;\n    var depth;\n\n    /*\n     * Eat initial spacing.\n     */\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_SPACE && character !== C_TAB) {\n            index--;\n            break;\n        }\n\n        subvalue += character;\n    }\n\n    /*\n     * Eat hashes.\n     */\n\n    depth = 0;\n    length = index + MAX_ATX_COUNT + 1;\n\n    while (++index <= length) {\n        character = value.charAt(index);\n\n        if (character !== C_HASH) {\n            index--;\n            break;\n        }\n\n        subvalue += character;\n        depth++;\n    }\n\n    if (\n        !depth ||\n        (!settings.pedantic && value.charAt(index + 1) === C_HASH)\n    ) {\n        return;\n    }\n\n    length = value.length + 1;\n\n    /*\n     * Eat intermediate white-space.\n     */\n\n    queue = EMPTY;\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_SPACE && character !== C_TAB) {\n            index--;\n            break;\n        }\n\n        queue += character;\n    }\n\n    /*\n     * Exit when not in pedantic mode without spacing.\n     */\n\n    if (\n        !settings.pedantic &&\n        !queue.length &&\n        character &&\n        character !== C_NEWLINE\n    ) {\n        return;\n    }\n\n    if (silent) {\n        return true;\n    }\n\n    /*\n     * Eat content.\n     */\n\n    subvalue += queue;\n    queue = content = EMPTY;\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (!character || character === C_NEWLINE) {\n            break;\n        }\n\n        if (\n            character !== C_SPACE &&\n            character !== C_TAB &&\n            character !== C_HASH\n        ) {\n            content += queue + character;\n            queue = EMPTY;\n            continue;\n        }\n\n        while (character === C_SPACE || character === C_TAB) {\n            queue += character;\n            character = value.charAt(++index);\n        }\n\n        while (character === C_HASH) {\n            queue += character;\n            character = value.charAt(++index);\n        }\n\n        while (character === C_SPACE || character === C_TAB) {\n            queue += character;\n            character = value.charAt(++index);\n        }\n\n        index--;\n    }\n\n    now.column += subvalue.length;\n    now.offset += subvalue.length;\n    subvalue += content + queue;\n\n    return eat(subvalue)(self.renderHeading(content, depth, now));\n}\n\n/**\n * Tokenise a Setext-style heading.\n *\n * @example\n *   tokenizeSetextHeading(eat, 'foo\\n===');\n *\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `heading` node.\n */\nfunction tokenizeSetextHeading(eat, value, silent) {\n    var self = this;\n    var now = eat.now();\n    var length = value.length;\n    var index = -1;\n    var subvalue = EMPTY;\n    var content;\n    var queue;\n    var character;\n    var marker;\n    var depth;\n\n    /*\n     * Eat initial indentation.\n     */\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_SPACE || index >= MAX_LINE_HEADING_INDENT) {\n            index--;\n            break;\n        }\n\n        subvalue += character;\n    }\n\n    /*\n     * Eat content.\n     */\n\n    content = queue = EMPTY;\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (character === C_NEWLINE) {\n            index--;\n            break;\n        }\n\n        if (character === C_SPACE || character === C_TAB) {\n            queue += character;\n        } else {\n            content += queue + character;\n            queue = EMPTY;\n        }\n    }\n\n    now.column += subvalue.length;\n    now.offset += subvalue.length;\n    subvalue += content + queue;\n\n    /*\n     * Ensure the content is followed by a newline and a\n     * valid marker.\n     */\n\n    character = value.charAt(++index);\n    marker = value.charAt(++index);\n\n    if (character !== C_NEWLINE || !SETEXT_MARKERS[marker]) {\n        return;\n    }\n\n    subvalue += character;\n\n    /*\n     * Eat Setext-line.\n     */\n\n    queue = marker;\n    depth = SETEXT_MARKERS[marker];\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (character !== marker) {\n            if (character !== C_NEWLINE) {\n                return;\n            }\n\n            index--;\n            break;\n        }\n\n        queue += character;\n    }\n\n    if (silent) {\n        return true;\n    }\n\n    return eat(subvalue + queue)(self.renderHeading(content, depth, now));\n}\n\n/**\n * Tokenise a horizontal rule.\n *\n * @example\n *   tokenizeThematicBreak(eat, '***');\n *\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `thematicBreak` node.\n */\nfunction tokenizeThematicBreak(eat, value, silent) {\n    var self = this;\n    var index = -1;\n    var length = value.length + 1;\n    var subvalue = EMPTY;\n    var character;\n    var marker;\n    var markerCount;\n    var queue;\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_TAB && character !== C_SPACE) {\n            break;\n        }\n\n        subvalue += character;\n    }\n\n    if (RULE_MARKERS[character] !== true) {\n        return;\n    }\n\n    marker = character;\n    subvalue += character;\n    markerCount = 1;\n    queue = EMPTY;\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n            markerCount++;\n            subvalue += queue + marker;\n            queue = EMPTY;\n        } else if (character === C_SPACE) {\n            queue += character;\n        } else if (\n            markerCount >= THEMATIC_BREAK_MARKER_COUNT &&\n            (!character || character === C_NEWLINE)\n        ) {\n            subvalue += queue;\n\n            if (silent) {\n                return true;\n            }\n\n            return eat(subvalue)(self.renderVoid(T_THEMATIC_BREAK));\n        } else {\n            return;\n        }\n    }\n}\n\n/**\n * Tokenise a blockquote.\n *\n * @example\n *   tokenizeBlockquote(eat, '> Foo');\n *\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `blockquote` node.\n */\nfunction tokenizeBlockquote(eat, value, silent) {\n    var self = this;\n    var commonmark = self.options.commonmark;\n    var now = eat.now();\n    var indent = self.indent(now.line);\n    var length = value.length;\n    var values = [];\n    var contents = [];\n    var indents = [];\n    var add;\n    var tokenizers;\n    var index = 0;\n    var character;\n    var rest;\n    var nextIndex;\n    var content;\n    var line;\n    var startIndex;\n    var prefixed;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_SPACE && character !== C_TAB) {\n            break;\n        }\n\n        index++;\n    }\n\n    if (value.charAt(index) !== C_GT) {\n        return;\n    }\n\n    if (silent) {\n        return true;\n    }\n\n    tokenizers = self.blockTokenizers;\n    index = 0;\n\n    while (index < length) {\n        nextIndex = value.indexOf(C_NEWLINE, index);\n        startIndex = index;\n        prefixed = false;\n\n        if (nextIndex === -1) {\n            nextIndex = length;\n        }\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (character !== C_SPACE && character !== C_TAB) {\n                break;\n            }\n\n            index++;\n        }\n\n        if (value.charAt(index) === C_GT) {\n            index++;\n            prefixed = true;\n\n            if (value.charAt(index) === C_SPACE) {\n                index++;\n            }\n        } else {\n            index = startIndex;\n        }\n\n        content = value.slice(index, nextIndex);\n\n        if (!prefixed && !trim(content)) {\n            index = startIndex;\n            break;\n        }\n\n        if (!prefixed) {\n            rest = value.slice(index);\n\n            if (\n                commonmark &&\n                (\n                    tokenizers.indentedCode.call(self, eat, rest, true) ||\n                    tokenizers.fencedCode.call(self, eat, rest, true) ||\n                    tokenizers.atxHeading.call(self, eat, rest, true) ||\n                    tokenizers.setextHeading.call(self, eat, rest, true) ||\n                    tokenizers.thematicBreak.call(self, eat, rest, true) ||\n                    tokenizers.html.call(self, eat, rest, true) ||\n                    tokenizers.list.call(self, eat, rest, true)\n                )\n            ) {\n                break;\n            }\n\n            if (\n                !commonmark &&\n                (\n                    tokenizers.definition.call(self, eat, rest, true) ||\n                    tokenizers.footnote.call(self, eat, rest, true)\n                )\n            ) {\n                break;\n            }\n        }\n\n        line = startIndex === index ?\n            content :\n            value.slice(startIndex, nextIndex);\n\n        indents.push(index - startIndex);\n        values.push(line);\n        contents.push(content);\n\n        index = nextIndex + 1;\n    }\n\n    index = -1;\n    length = indents.length;\n    add = eat(values.join(C_NEWLINE));\n\n    while (++index < length) {\n        indent(indents[index]);\n    }\n\n    return add(self.renderBlockquote(contents.join(C_NEWLINE), now));\n}\n\n/**\n * Tokenise a list.\n *\n * @example\n *   tokenizeList(eat, '- Foo');\n *\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `list` node.\n */\nfunction tokenizeList(eat, value, silent) {\n    var self = this;\n    var commonmark = self.options.commonmark;\n    var pedantic = self.options.pedantic;\n    var tokenizers = self.blockTokenizers;\n    var markers;\n    var index = 0;\n    var length = value.length;\n    var start = null;\n    var queue;\n    var ordered;\n    var character;\n    var marker;\n    var nextIndex;\n    var startIndex;\n    var prefixed;\n    var currentMarker;\n    var content;\n    var line;\n    var prevEmpty;\n    var empty;\n    var items;\n    var allLines;\n    var emptyLines;\n    var item;\n    var enterTop;\n    var exitBlockquote;\n    var isLoose;\n    var node;\n    var now;\n    var end;\n    var indented;\n    var size;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_SPACE && character !== C_TAB) {\n            break;\n        }\n\n        index++;\n    }\n\n    character = value.charAt(index);\n\n    markers = commonmark ?\n        LIST_ORDERED_COMMONMARK_MARKERS :\n        LIST_ORDERED_MARKERS;\n\n    if (LIST_UNORDERED_MARKERS[character] === true) {\n        marker = character;\n        ordered = false;\n    } else {\n        ordered = true;\n        queue = EMPTY;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (!isNumeric(character)) {\n                break;\n            }\n\n            queue += character;\n            index++;\n        }\n\n        character = value.charAt(index);\n\n        if (!queue || markers[character] !== true) {\n            return;\n        }\n\n        start = parseInt(queue, 10);\n        marker = character;\n    }\n\n    character = value.charAt(++index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n        return;\n    }\n\n    if (silent) {\n        return true;\n    }\n\n    index = 0;\n    items = [];\n    allLines = [];\n    emptyLines = [];\n\n    while (index < length) {\n        nextIndex = value.indexOf(C_NEWLINE, index);\n        startIndex = index;\n        prefixed = false;\n        indented = false;\n\n        if (nextIndex === -1) {\n            nextIndex = length;\n        }\n\n        end = index + TAB_SIZE;\n        size = 0;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (character === C_TAB) {\n                size += TAB_SIZE - size % TAB_SIZE;\n            } else if (character === C_SPACE) {\n                size++;\n            } else {\n                break;\n            }\n\n            index++;\n        }\n\n        if (size >= TAB_SIZE) {\n            indented = true;\n        }\n\n        if (item && size >= item.indent) {\n            indented = true;\n        }\n\n        character = value.charAt(index);\n        currentMarker = null;\n\n        if (!indented) {\n            if (LIST_UNORDERED_MARKERS[character] === true) {\n                currentMarker = character;\n                index++;\n                size++;\n            } else {\n                queue = EMPTY;\n\n                while (index < length) {\n                    character = value.charAt(index);\n\n                    if (!isNumeric(character)) {\n                        break;\n                    }\n\n                    queue += character;\n                    index++;\n                }\n\n                character = value.charAt(index);\n                index++;\n\n                if (queue && markers[character] === true) {\n                    currentMarker = character;\n                    size += queue.length + 1;\n                }\n            }\n\n            if (currentMarker) {\n                character = value.charAt(index);\n\n                if (character === C_TAB) {\n                    size += TAB_SIZE - size % TAB_SIZE;\n                    index++;\n                } else if (character === C_SPACE) {\n                    end = index + TAB_SIZE;\n\n                    while (index < end) {\n                        if (value.charAt(index) !== C_SPACE) {\n                            break;\n                        }\n\n                        index++;\n                        size++;\n                    }\n\n                    if (index === end && value.charAt(index) === C_SPACE) {\n                        index -= TAB_SIZE - 1;\n                        size -= TAB_SIZE - 1;\n                    }\n                } else if (\n                    character !== C_NEWLINE &&\n                    character !== EMPTY\n                ) {\n                    currentMarker = null;\n                }\n            }\n        }\n\n        if (currentMarker) {\n            if (commonmark && marker !== currentMarker) {\n                break;\n            }\n\n            prefixed = true;\n        } else {\n            if (\n                !commonmark &&\n                !indented &&\n                value.charAt(startIndex) === C_SPACE\n            ) {\n                indented = true;\n            } else if (\n                commonmark &&\n                item\n            ) {\n                indented = size >= item.indent || size > TAB_SIZE;\n            }\n\n            prefixed = false;\n            index = startIndex;\n        }\n\n        line = value.slice(startIndex, nextIndex);\n        content = startIndex === index ? line : value.slice(index, nextIndex);\n\n        if (currentMarker && RULE_MARKERS[currentMarker] === true) {\n            if (\n                tokenizers.thematicBreak.call(self, eat, line, true)\n            ) {\n                break;\n            }\n        }\n\n        prevEmpty = empty;\n        empty = !trim(content).length;\n\n        if (indented && item) {\n            item.value = item.value.concat(emptyLines, line);\n            allLines = allLines.concat(emptyLines, line);\n            emptyLines = [];\n        } else if (prefixed) {\n            if (emptyLines.length) {\n                item.value.push(EMPTY);\n                item.trail = emptyLines.concat();\n            }\n\n            item = {\n                // 'bullet': value.slice(startIndex, index),\n                'value': [line],\n                'indent': size,\n                'trail': []\n            };\n\n            items.push(item);\n            allLines = allLines.concat(emptyLines, line);\n            emptyLines = [];\n        } else if (empty) {\n            // TODO: disable when in pedantic-mode.\n            if (prevEmpty) {\n                break;\n            }\n\n            emptyLines.push(line);\n        } else {\n            if (prevEmpty) {\n                break;\n            }\n\n            if (\n                !pedantic &&\n                (\n                    tokenizers.fencedCode.call(self, eat, line, true) ||\n                    tokenizers.thematicBreak.call(self, eat, line, true)\n                )\n            ) {\n                break;\n            }\n\n            if (!commonmark) {\n                if (\n                    tokenizers.definition.call(self, eat, line, true) ||\n                    tokenizers.footnote.call(self, eat, line, true)\n                ) {\n                    break;\n                }\n            }\n\n            item.value = item.value.concat(emptyLines, line);\n            allLines = allLines.concat(emptyLines, line);\n            emptyLines = [];\n        }\n\n        index = nextIndex + 1;\n    }\n\n    node = eat(allLines.join(C_NEWLINE)).reset({\n        'type': T_LIST,\n        'ordered': ordered,\n        'start': start,\n        'loose': null,\n        'children': []\n    });\n\n    enterTop = self.enterList();\n    exitBlockquote = self.enterBlock();\n    isLoose = false;\n    index = -1;\n    length = items.length;\n\n    while (++index < length) {\n        item = items[index].value.join(C_NEWLINE);\n        now = eat.now();\n\n        item = eat(item)(self.renderListItem(item, now), node);\n\n        if (item.loose) {\n            isLoose = true;\n        }\n\n        item = items[index].trail.join(C_NEWLINE);\n\n        if (index !== length - 1) {\n            item += C_NEWLINE;\n        }\n\n        eat(item);\n    }\n\n    enterTop();\n    exitBlockquote();\n\n    node.loose = isLoose;\n\n    return node;\n}\n\n/**\n * Try to match comment.\n *\n * @param {string} value - Value to parse.\n * @param {Object} settings - Configuration as available on\n *   a parser.\n * @return {string?} - When applicable, the comment at the\n *   start of `value`.\n */\nfunction eatHTMLComment(value, settings) {\n    var index = COMMENT_START_LENGTH;\n    var queue = COMMENT_START;\n    var length = value.length;\n    var commonmark = settings.commonmark;\n    var character;\n    var hasNonDash;\n\n    if (value.slice(0, index) === queue) {\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (\n                character === COMMENT_END_CHAR &&\n                value.slice(index, index + COMMENT_END_LENGTH) === COMMENT_END\n            ) {\n                return queue + COMMENT_END;\n            }\n\n            if (commonmark) {\n                if (character === C_GT && !hasNonDash) {\n                    return;\n                }\n\n                if (character === C_DASH) {\n                    if (value.charAt(index + 1) === C_DASH) {\n                        return;\n                    }\n                } else {\n                    hasNonDash = true;\n                }\n            }\n\n            queue += character;\n            index++;\n        }\n    }\n}\n\n/**\n * Try to match CDATA.\n *\n * @param {string} value - Value to parse.\n * @return {string?} - When applicable, the CDATA at the\n *   start of `value`.\n */\nfunction eatHTMLCDATA(value) {\n    var index = CDATA_START_LENGTH;\n    var queue = value.slice(0, index);\n    var length = value.length;\n    var character;\n\n    if (queue.toUpperCase() === CDATA_START) {\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (\n                character === CDATA_END_CHAR &&\n                value.slice(index, index + CDATA_END_LENGTH) === CDATA_END\n            ) {\n                return queue + CDATA_END;\n            }\n\n            queue += character;\n            index++;\n        }\n    }\n}\n\n/**\n * Try to match a processing instruction.\n *\n * @param {string} value - Value to parse.\n * @return {string?} - When applicable, the processing\n *   instruction at the start of `value`.\n */\nfunction eatHTMLProcessingInstruction(value) {\n    var index = 0;\n    var queue = EMPTY;\n    var length = value.length;\n    var character;\n\n    if (\n        value.charAt(index) === C_LT &&\n        value.charAt(++index) === C_QUESTION_MARK\n    ) {\n        queue = C_LT + C_QUESTION_MARK;\n        index++;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (\n                character === C_QUESTION_MARK &&\n                value.charAt(index + 1) === C_GT\n            ) {\n                return queue + character + C_GT;\n            }\n\n            queue += character;\n            index++;\n        }\n    }\n}\n\n/**\n * Try to match a declaration.\n *\n * @param {string} value - Value to parse.\n * @return {string?} - When applicable, the declaration at\n *   the start of `value`.\n */\nfunction eatHTMLDeclaration(value) {\n    var index = 0;\n    var length = value.length;\n    var queue = EMPTY;\n    var subqueue = EMPTY;\n    var character;\n\n    if (\n        value.charAt(index) === C_LT &&\n        value.charAt(++index) === C_EXCLAMATION_MARK\n    ) {\n        queue = C_LT + C_EXCLAMATION_MARK;\n        index++;\n\n        /*\n         * Eat as many alphabetic characters as\n         * possible.\n         */\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (!isAlphabetic(character)) {\n                break;\n            }\n\n            subqueue += character;\n            index++;\n        }\n\n        character = value.charAt(index);\n\n        if (!subqueue || !isWhiteSpace(character)) {\n            return;\n        }\n\n        queue += subqueue + character;\n        index++;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (character === C_GT) {\n                return queue;\n            }\n\n            queue += character;\n            index++;\n        }\n    }\n}\n\n/**\n * Try to match a closing tag.\n *\n * @param {string} value - Value to parse.\n * @param {boolean?} [isBlock] - Whether the tag-name\n *   must be a known block-level node to match.\n * @return {string?} - When applicable, the closing tag at\n *   the start of `value`.\n */\nfunction eatHTMLClosingTag(value, isBlock) {\n    var index = 0;\n    var length = value.length;\n    var queue = EMPTY;\n    var subqueue = EMPTY;\n    var character;\n\n    if (\n        value.charAt(index) === C_LT &&\n        value.charAt(++index) === C_SLASH\n    ) {\n        queue = C_LT + C_SLASH;\n        subqueue = character = value.charAt(++index);\n\n        if (!isAlphabetic(character)) {\n            return;\n        }\n\n        index++;\n\n        /*\n         * Eat as many alphabetic characters as\n         * possible.\n         */\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (!isAlphabetic(character) && !isNumeric(character)) {\n                break;\n            }\n\n            subqueue += character;\n            index++;\n        }\n\n        if (isBlock && blockElements.indexOf(subqueue.toLowerCase()) === -1) {\n            return;\n        }\n\n        queue += subqueue;\n\n        /*\n         * Eat white-space.\n         */\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (!isWhiteSpace(character)) {\n                break;\n            }\n\n            queue += character;\n            index++;\n        }\n\n        if (value.charAt(index) === C_GT) {\n            return queue + C_GT;\n        }\n    }\n}\n\n/**\n * Try to match an opening tag.\n *\n * @param {string} value - Value to parse.\n * @param {boolean?} [isBlock] - Whether the tag-name\n *   must be a known block-level node to match.\n * @return {string?} - When applicable, the opening tag at\n *   the start of `value`.\n */\nfunction eatHTMLOpeningTag(value, isBlock) {\n    var index = 0;\n    var length = value.length;\n    var queue = EMPTY;\n    var subqueue = EMPTY;\n    var character = value.charAt(index);\n    var hasEquals;\n    var test;\n\n    if (character === C_LT) {\n        queue = character;\n        subqueue = character = value.charAt(++index);\n\n        if (!isAlphabetic(character)) {\n            return;\n        }\n\n        index++;\n\n        /*\n         * Eat as many alphabetic characters as\n         * possible.\n         */\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (!isAlphabetic(character) && !isNumeric(character)) {\n                break;\n            }\n\n            subqueue += character;\n            index++;\n        }\n\n        if (isBlock && blockElements.indexOf(subqueue.toLowerCase()) === -1) {\n            return;\n        }\n\n        queue += subqueue;\n        subqueue = EMPTY;\n\n        /*\n         * Find attributes.\n         */\n\n        while (index < length) {\n            /*\n             * Eat white-space.\n             */\n\n            while (index < length) {\n                character = value.charAt(index);\n\n                if (!isWhiteSpace(character)) {\n                    break;\n                }\n\n                subqueue += character;\n                index++;\n            }\n\n            if (!subqueue) {\n                break;\n            }\n\n            /*\n             * Eat an attribute name.\n             */\n\n            queue += subqueue;\n            subqueue = EMPTY;\n            character = value.charAt(index);\n\n            if (\n                isAlphabetic(character) ||\n                character === C_UNDERSCORE ||\n                character === C_COLON\n            ) {\n                subqueue = character;\n                index++;\n\n                while (index < length) {\n                    character = value.charAt(index);\n\n                    if (\n                        !isAlphabetic(character) &&\n                        !isNumeric(character) &&\n                        character !== C_UNDERSCORE &&\n                        character !== C_COLON &&\n                        character !== C_DOT &&\n                        character !== C_DASH\n                    ) {\n                        break;\n                    }\n\n                    subqueue += character;\n                    index++;\n                }\n            }\n\n            if (!subqueue) {\n                break;\n            }\n\n            queue += subqueue;\n            subqueue = EMPTY;\n            hasEquals = false;\n\n            /*\n             * Eat zero or more white-space and one\n             * equals sign.\n             */\n\n            while (index < length) {\n                character = value.charAt(index);\n\n                if (!isWhiteSpace(character)) {\n                    if (!hasEquals && character === C_EQUALS) {\n                        hasEquals = true;\n                    } else {\n                        break;\n                    }\n                }\n\n                subqueue += character;\n                index++;\n            }\n\n            queue += subqueue;\n            subqueue = EMPTY;\n\n            if (!hasEquals) {\n                queue += subqueue;\n            } else {\n                character = value.charAt(index);\n                queue += subqueue;\n\n                if (character === C_DOUBLE_QUOTE) {\n                    test = isDoubleQuotedAttributeCharacter;\n                    subqueue = character;\n                    index++;\n                } else if (character === C_SINGLE_QUOTE) {\n                    test = isSingleQuotedAttributeCharacter;\n                    subqueue = character;\n                    index++;\n                } else {\n                    test = isUnquotedAttributeCharacter;\n                    subqueue = EMPTY;\n                }\n\n                while (index < length) {\n                    character = value.charAt(index);\n\n                    if (!test(character)) {\n                        break;\n                    }\n\n                    subqueue += character;\n                    index++;\n                }\n\n                character = value.charAt(index);\n                index++;\n\n                if (!test.delimiter) {\n                    if (!subqueue.length) {\n                        return;\n                    }\n\n                    index--;\n                } else if (character === test.delimiter) {\n                    subqueue += character;\n                } else {\n                    return;\n                }\n\n                queue += subqueue;\n                subqueue = EMPTY;\n            }\n        }\n\n        /*\n         * More white-space is already eaten by the\n         * attributes subroutine.\n         */\n\n        character = value.charAt(index);\n\n        /*\n         * Eat an optional backslash (for self-closing\n         * tags).\n         */\n\n        if (character === C_SLASH) {\n            queue += character;\n            character = value.charAt(++index);\n        }\n\n        return character === C_GT ? queue + character : null;\n    }\n}\n\n/**\n * Tokenise HTML.\n *\n * @example\n *   tokenizeBlockHTML(eat, '<span>foo</span>');\n *\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `html` node.\n */\nfunction tokenizeBlockHTML(eat, value, silent) {\n    var self = this;\n    var index = 0;\n    var length = value.length;\n    var subvalue = EMPTY;\n    var offset;\n    var lineCount;\n    var character;\n    var queue;\n\n    /*\n     * Eat initial spacing.\n     */\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_TAB && character !== C_SPACE) {\n            break;\n        }\n\n        subvalue += character;\n        index++;\n    }\n\n    offset = index;\n    value = value.slice(offset);\n\n    /*\n     * Try to eat an HTML thing.\n     */\n\n    queue = eatHTMLComment(value, self.options) ||\n        eatHTMLCDATA(value) ||\n        eatHTMLProcessingInstruction(value) ||\n        eatHTMLDeclaration(value) ||\n        eatHTMLClosingTag(value, true) ||\n        eatHTMLOpeningTag(value, true);\n\n    if (!queue) {\n        return;\n    }\n\n    if (silent) {\n        return true;\n    }\n\n    subvalue += queue;\n    index = subvalue.length - offset;\n    queue = EMPTY;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character === C_NEWLINE) {\n            queue += character;\n            lineCount++;\n        } else if (queue.length < MIN_CLOSING_HTML_NEWLINE_COUNT) {\n            subvalue += queue + character;\n            queue = EMPTY;\n        } else {\n            break;\n        }\n\n        index++;\n    }\n\n    return eat(subvalue)(self.renderRaw(T_HTML, subvalue));\n}\n\n/**\n * Tokenise a definition.\n *\n * @example\n *   var value = '[foo]: http://example.com \"Example Domain\"';\n *   tokenizeDefinition(eat, value);\n *\n * @property {boolean} notInList\n * @property {boolean} notInBlock\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `definition` node.\n */\nfunction tokenizeDefinition(eat, value, silent) {\n    var self = this;\n    var commonmark = self.options.commonmark;\n    var index = 0;\n    var length = value.length;\n    var subvalue = EMPTY;\n    var beforeURL;\n    var beforeTitle;\n    var queue;\n    var character;\n    var test;\n    var identifier;\n    var url;\n    var title;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_SPACE && character !== C_TAB) {\n            break;\n        }\n\n        subvalue += character;\n        index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character !== C_BRACKET_OPEN) {\n        return;\n    }\n\n    index++;\n    subvalue += character;\n    queue = EMPTY;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character === C_BRACKET_CLOSE) {\n            break;\n        } else if (character === C_BACKSLASH) {\n            queue += character;\n            index++;\n            character = value.charAt(index);\n        }\n\n        queue += character;\n        index++;\n    }\n\n    if (\n        !queue ||\n        value.charAt(index) !== C_BRACKET_CLOSE ||\n        value.charAt(index + 1) !== C_COLON\n    ) {\n        return;\n    }\n\n    identifier = queue;\n    subvalue += queue + C_BRACKET_CLOSE + C_COLON;\n    index = subvalue.length;\n    queue = EMPTY;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (\n            character !== C_TAB &&\n            character !== C_SPACE &&\n            character !== C_NEWLINE\n        ) {\n            break;\n        }\n\n        subvalue += character;\n        index++;\n    }\n\n    character = value.charAt(index);\n    queue = EMPTY;\n    beforeURL = subvalue;\n\n    if (character === C_LT) {\n        index++;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (!isEnclosedURLCharacter(character)) {\n                break;\n            }\n\n            queue += character;\n            index++;\n        }\n\n        character = value.charAt(index);\n\n        if (character !== isEnclosedURLCharacter.delimiter) {\n            if (commonmark) {\n                return;\n            }\n\n            index -= queue.length + 1;\n            queue = EMPTY;\n        } else {\n            subvalue += C_LT + queue + character;\n            index++;\n        }\n    }\n\n    if (!queue) {\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (!isUnclosedURLCharacter(character)) {\n                break;\n            }\n\n            queue += character;\n            index++;\n        }\n\n        subvalue += queue;\n    }\n\n    if (!queue) {\n        return;\n    }\n\n    url = queue;\n    queue = EMPTY;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (\n            character !== C_TAB &&\n            character !== C_SPACE &&\n            character !== C_NEWLINE\n        ) {\n            break;\n        }\n\n        queue += character;\n        index++;\n    }\n\n    character = value.charAt(index);\n    test = null;\n\n    if (character === C_DOUBLE_QUOTE) {\n        test = C_DOUBLE_QUOTE;\n    } else if (character === C_SINGLE_QUOTE) {\n        test = C_SINGLE_QUOTE;\n    } else if (character === C_PAREN_OPEN) {\n        test = C_PAREN_CLOSE;\n    }\n\n    if (!test) {\n        queue = EMPTY;\n        index = subvalue.length;\n    } else if (!queue) {\n        return;\n    } else {\n        subvalue += queue + character;\n        index = subvalue.length;\n        queue = EMPTY;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (character === test) {\n                break;\n            }\n\n            if (character === C_NEWLINE) {\n                index++;\n                character = value.charAt(index);\n\n                if (character === C_NEWLINE || character === test) {\n                    return;\n                }\n\n                queue += C_NEWLINE;\n            }\n\n            queue += character;\n            index++;\n        }\n\n        character = value.charAt(index);\n\n        if (character !== test) {\n            return;\n        }\n\n        beforeTitle = subvalue;\n        subvalue += queue + character;\n        index++;\n        title = queue;\n        queue = EMPTY;\n    }\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_TAB && character !== C_SPACE) {\n            break;\n        }\n\n        subvalue += character;\n        index++;\n    }\n\n    character = value.charAt(index);\n\n    if (!character || character === C_NEWLINE) {\n        if (silent) {\n            return true;\n        }\n\n        beforeURL = eat(beforeURL).test().end;\n        url = self.decode.raw(self.descape(url), beforeURL);\n\n        if (title) {\n            beforeTitle = eat(beforeTitle).test().end;\n            title = self.decode.raw(self.descape(title), beforeTitle);\n        }\n\n        return eat(subvalue)({\n            'type': T_DEFINITION,\n            'identifier': normalize(identifier),\n            'title': title || null,\n            'url': url\n        });\n    }\n}\n\ntokenizeDefinition.notInList = true;\ntokenizeDefinition.notInBlock = true;\n\n/**\n * Tokenise YAML front matter.\n *\n * @example\n *   tokenizeYAMLFrontMatter(eat, '---\\nfoo: bar\\n---');\n *\n * @property {boolean} onlyAtStart\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `yaml` node.\n */\nfunction tokenizeYAMLFrontMatter(eat, value, silent) {\n    var self = this;\n    var subvalue;\n    var content;\n    var index;\n    var length;\n    var character;\n    var queue;\n\n    if (\n        !self.options.yaml ||\n        value.charAt(0) !== C_DASH ||\n        value.charAt(1) !== C_DASH ||\n        value.charAt(2) !== C_DASH ||\n        value.charAt(3) !== C_NEWLINE\n    ) {\n        return;\n    }\n\n    subvalue = YAML_FENCE + C_NEWLINE;\n    content = queue = EMPTY;\n    index = 3;\n    length = value.length;\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (\n            character === C_DASH &&\n            (queue || !content) &&\n            value.charAt(index + 1) === C_DASH &&\n            value.charAt(index + 2) === C_DASH\n        ) {\n            /* istanbul ignore if - never used (yet) */\n            if (silent) {\n                return true;\n            }\n\n            subvalue += queue + YAML_FENCE;\n\n            return eat(subvalue)(self.renderRaw(T_YAML, content));\n        }\n\n        if (character === C_NEWLINE) {\n            queue += character;\n        } else {\n            subvalue += queue + character;\n            content += queue + character;\n            queue = EMPTY;\n        }\n    }\n}\n\ntokenizeYAMLFrontMatter.onlyAtStart = true;\n\n/**\n * Tokenise a footnote definition.\n *\n * @example\n *   tokenizeFootnoteDefinition(eat, '[^foo]: Bar.');\n *\n * @property {boolean} notInList\n * @property {boolean} notInBlock\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `footnoteDefinition` node.\n */\nfunction tokenizeFootnoteDefinition(eat, value, silent) {\n    var self = this;\n    var index;\n    var length;\n    var subvalue;\n    var now;\n    var indent;\n    var content;\n    var queue;\n    var subqueue;\n    var character;\n    var identifier;\n\n    if (!self.options.footnotes) {\n        return;\n    }\n\n    index = 0;\n    length = value.length;\n    subvalue = EMPTY;\n    now = eat.now();\n    indent = self.indent(now.line);\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (!isWhiteSpace(character)) {\n            break;\n        }\n\n        subvalue += character;\n        index++;\n    }\n\n    if (\n        value.charAt(index) !== C_BRACKET_OPEN ||\n        value.charAt(index + 1) !== C_CARET\n    ) {\n        return;\n    }\n\n    subvalue += C_BRACKET_OPEN + C_CARET;\n    index = subvalue.length;\n    queue = EMPTY;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character === C_BRACKET_CLOSE) {\n            break;\n        } else if (character === C_BACKSLASH) {\n            queue += character;\n            index++;\n            character = value.charAt(index);\n        }\n\n        queue += character;\n        index++;\n    }\n\n    if (\n        !queue ||\n        value.charAt(index) !== C_BRACKET_CLOSE ||\n        value.charAt(index + 1) !== C_COLON\n    ) {\n        return;\n    }\n\n    if (silent) {\n        return true;\n    }\n\n    identifier = normalize(queue);\n    subvalue += queue + C_BRACKET_CLOSE + C_COLON;\n    index = subvalue.length;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (\n            character !== C_TAB &&\n            character !== C_SPACE\n        ) {\n            break;\n        }\n\n        subvalue += character;\n        index++;\n    }\n\n    now.column += subvalue.length;\n    now.offset += subvalue.length;\n    queue = content = subqueue = EMPTY;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character === C_NEWLINE) {\n            subqueue = character;\n            index++;\n\n            while (index < length) {\n                character = value.charAt(index);\n\n                if (character !== C_NEWLINE) {\n                    break;\n                }\n\n                subqueue += character;\n                index++;\n            }\n\n            queue += subqueue;\n            subqueue = EMPTY;\n\n            while (index < length) {\n                character = value.charAt(index);\n\n                if (character !== C_SPACE) {\n                    break;\n                }\n\n                subqueue += character;\n                index++;\n            }\n\n            if (!subqueue.length) {\n                break;\n            }\n\n            queue += subqueue;\n        }\n\n        if (queue) {\n            content += queue;\n            queue = EMPTY;\n        }\n\n        content += character;\n        index++;\n    }\n\n    subvalue += content;\n\n    content = content.replace(EXPRESSION_INITIAL_TAB, function (line) {\n        indent(line.length);\n\n        return EMPTY;\n    });\n\n    return eat(subvalue)(\n        self.renderFootnoteDefinition(identifier, content, now)\n    );\n}\n\ntokenizeFootnoteDefinition.notInList = true;\ntokenizeFootnoteDefinition.notInBlock = true;\n\n/**\n * Tokenise a table.\n *\n * @example\n *   tokenizeTable(eat, ' | foo |\\n | --- |\\n | bar |');\n *\n * @property {boolean} notInList\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `table` node.\n */\nfunction tokenizeTable(eat, value, silent) {\n    var self = this;\n    var index;\n    var alignments;\n    var alignment;\n    var subvalue;\n    var row;\n    var length;\n    var lines;\n    var queue;\n    var character;\n    var hasDash;\n    var align;\n    var cell;\n    var preamble;\n    var count;\n    var opening;\n    var now;\n    var position;\n    var lineCount;\n    var line;\n    var rows;\n    var table;\n    var lineIndex;\n    var pipeIndex;\n    var first;\n\n    /*\n     * Exit when not in gfm-mode.\n     */\n\n    if (!self.options.gfm) {\n        return;\n    }\n\n    /*\n     * Get the rows.\n     * Detecting tables soon is hard, so there are some\n     * checks for performance here, such as the minimum\n     * number of rows, and allowed characters in the\n     * alignment row.\n     */\n\n    index = lineCount = 0;\n    length = value.length + 1;\n    lines = [];\n\n    while (index < length) {\n        lineIndex = value.indexOf(C_NEWLINE, index);\n        pipeIndex = value.indexOf(C_PIPE, index + 1);\n\n        if (lineIndex === -1) {\n            lineIndex = value.length;\n        }\n\n        if (\n            pipeIndex === -1 ||\n            pipeIndex > lineIndex\n        ) {\n            if (lineCount < MIN_TABLE_ROWS) {\n                return;\n            }\n\n            break;\n        }\n\n        lines.push(value.slice(index, lineIndex));\n        lineCount++;\n        index = lineIndex + 1;\n    }\n\n    /*\n     * Parse the alignment row.\n     */\n\n    subvalue = lines.join(C_NEWLINE);\n    alignments = lines.splice(1, 1)[0] || [];\n    index = 0;\n    length = alignments.length;\n    lineCount--;\n    alignment = false;\n    align = [];\n\n    while (index < length) {\n        character = alignments.charAt(index);\n\n        if (character === C_PIPE) {\n            hasDash = null;\n\n            if (alignment === false) {\n                if (first === false) {\n                    return;\n                }\n            } else {\n                align.push(alignment);\n                alignment = false;\n            }\n\n            first = false;\n        } else if (character === C_DASH) {\n            hasDash = true;\n            alignment = alignment || TABLE_ALIGN_NONE;\n        } else if (character === C_COLON) {\n            if (alignment === TABLE_ALIGN_LEFT) {\n                alignment = TABLE_ALIGN_CENTER;\n            } else if (hasDash && alignment === TABLE_ALIGN_NONE) {\n                alignment = TABLE_ALIGN_RIGHT;\n            } else {\n                alignment = TABLE_ALIGN_LEFT;\n            }\n        } else if (!isWhiteSpace(character)) {\n            return;\n        }\n\n        index++;\n    }\n\n    if (alignment !== false) {\n        align.push(alignment);\n    }\n\n    /*\n     * Exit when without enough columns.\n     */\n\n    if (align.length < MIN_TABLE_COLUMNS) {\n        return;\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n        return true;\n    }\n\n    /*\n     * Parse the rows.\n     */\n\n    position = -1;\n    rows = [];\n\n    table = eat(subvalue).reset({\n        'type': T_TABLE,\n        'align': align,\n        'children': rows\n    });\n\n    while (++position < lineCount) {\n        line = lines[position];\n        row = self.renderParent(position ? T_TABLE_ROW : T_TABLE_HEADER, []);\n\n        /*\n         * Eat a newline character when this is not the\n         * first row.\n         */\n\n        if (position) {\n            eat(C_NEWLINE);\n        }\n\n        /*\n         * Eat the row.\n         */\n\n        eat(line).reset(row, table);\n\n        length = line.length + 1;\n        index = 0;\n        queue = EMPTY;\n        cell = EMPTY;\n        preamble = true;\n        count = opening = null;\n\n        while (index < length) {\n            character = line.charAt(index);\n\n            if (character === C_TAB || character === C_SPACE) {\n                if (cell) {\n                    queue += character;\n                } else {\n                    eat(character);\n                }\n\n                index++;\n                continue;\n            }\n\n            if (character === EMPTY || character === C_PIPE) {\n                if (preamble) {\n                    eat(character);\n                } else {\n                    if (character && opening) {\n                        queue += character;\n                        index++;\n                        continue;\n                    }\n\n                    if ((cell || character) && !preamble) {\n                        subvalue = cell;\n\n                        if (queue.length > 1) {\n                            if (character) {\n                                subvalue += queue.slice(0, queue.length - 1);\n                                queue = queue.charAt(queue.length - 1);\n                            } else {\n                                subvalue += queue;\n                                queue = EMPTY;\n                            }\n                        }\n\n                        now = eat.now();\n\n                        eat(subvalue)(\n                            self.renderInline(T_TABLE_CELL, cell, now), row\n                        );\n                    }\n\n                    eat(queue + character);\n\n                    queue = EMPTY;\n                    cell = EMPTY;\n                }\n            } else {\n                if (queue) {\n                    cell += queue;\n                    queue = EMPTY;\n                }\n\n                cell += character;\n\n                if (character === C_BACKSLASH && index !== length - 2) {\n                    cell += line.charAt(index + 1);\n                    index++;\n                }\n\n                if (character === C_TICK) {\n                    count = 1;\n\n                    while (line.charAt(index + 1) === character) {\n                        cell += character;\n                        index++;\n                        count++;\n                    }\n\n                    if (!opening) {\n                        opening = count;\n                    } else if (count >= opening) {\n                        opening = 0;\n                    }\n                }\n            }\n\n            preamble = false;\n            index++;\n        }\n\n        /*\n         * Eat the alignment row.\n         */\n\n        if (!position) {\n            eat(C_NEWLINE + alignments);\n        }\n    }\n\n    return table;\n}\n\ntokenizeTable.notInList = true;\n\n/**\n * Tokenise a paragraph node.\n *\n * @example\n *   tokenizeParagraph(eat, 'Foo.');\n *\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `paragraph` node.\n */\nfunction tokenizeParagraph(eat, value, silent) {\n    var self = this;\n    var settings = self.options;\n    var commonmark = settings.commonmark;\n    var gfm = settings.gfm;\n    var tokenizers = self.blockTokenizers;\n    var index = value.indexOf(C_NEWLINE);\n    var length = value.length;\n    var position;\n    var subvalue;\n    var character;\n    var size;\n    var now;\n\n    while (index < length) {\n        /*\n         * Eat everything if theres no following newline.\n         */\n\n        if (index === -1) {\n            index = length;\n            break;\n        }\n\n        /*\n         * Stop if the next character is NEWLINE.\n         */\n\n        if (value.charAt(index + 1) === C_NEWLINE) {\n            break;\n        }\n\n        /*\n         * In commonmark-mode, following indented lines\n         * are part of the paragraph.\n         */\n\n        if (commonmark) {\n            size = 0;\n            position = index + 1;\n\n            while (position < length) {\n                character = value.charAt(position);\n\n                if (character === C_TAB) {\n                    size = TAB_SIZE;\n                    break;\n                } else if (character === C_SPACE) {\n                    size++;\n                } else {\n                    break;\n                }\n\n                position++;\n            }\n\n            if (size >= TAB_SIZE) {\n                index = value.indexOf(C_NEWLINE, index + 1);\n                continue;\n            }\n        }\n\n        /*\n         * Check if the following code contains a possible\n         * block.\n         */\n\n        subvalue = value.slice(index + 1);\n\n        if (\n            tokenizers.thematicBreak.call(self, eat, subvalue, true) ||\n            tokenizers.atxHeading.call(self, eat, subvalue, true) ||\n            tokenizers.fencedCode.call(self, eat, subvalue, true) ||\n            tokenizers.blockquote.call(self, eat, subvalue, true) ||\n            tokenizers.html.call(self, eat, subvalue, true)\n        ) {\n            break;\n        }\n\n        /*\n         * Break if the following line starts a list, when\n         * already in a list, or when in commonmark, or when\n         * in gfm mode and the bullet is *not* numeric.\n         */\n\n        if (\n            tokenizers.list.call(self, eat, subvalue, true) &&\n            (\n                self.inList ||\n                commonmark ||\n                (gfm && !isNumeric(trim.left(subvalue).charAt(0)))\n            )\n        ) {\n            break;\n        }\n\n        if (\n            !commonmark &&\n            (\n                tokenizers.setextHeading.call(self, eat, subvalue, true) ||\n                tokenizers.definition.call(self, eat, subvalue, true) ||\n                tokenizers.footnote.call(self, eat, subvalue, true)\n            )\n        ) {\n            break;\n        }\n\n        position = index;\n        index = value.indexOf(C_NEWLINE, index + 1);\n\n        if (index !== -1 && trim(value.slice(position, index)) === EMPTY) {\n            index = position;\n            break;\n        }\n    }\n\n    subvalue = value.slice(0, index);\n\n    if (trim(subvalue) === EMPTY) {\n        eat(subvalue);\n\n        return null;\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n        return true;\n    }\n\n    now = eat.now();\n    subvalue = trimTrailingLines(subvalue);\n\n    return eat(subvalue)(self.renderInline(T_PARAGRAPH, subvalue, now));\n}\n\n/**\n * Tokenise a text node.\n *\n * @example\n *   tokenizeText(eat, 'foo');\n *\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `text` node.\n */\nfunction tokenizeText(eat, value, silent) {\n    var self = this;\n    var methods;\n    var tokenizers;\n    var index;\n    var length;\n    var subvalue;\n    var position;\n    var tokenizer;\n    var name;\n    var min;\n    var now;\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n        return true;\n    }\n\n    methods = self.inlineMethods;\n    length = methods.length;\n    tokenizers = self.inlineTokenizers;\n    index = -1;\n    min = value.length;\n\n    while (++index < length) {\n        name = methods[index];\n\n        if (name === 'text' || !tokenizers[name]) {\n            continue;\n        }\n\n        tokenizer = tokenizers[name].locator;\n\n        if (!tokenizer) {\n            eat.file.fail(ERR_MISSING_LOCATOR + C_TICK + name + C_TICK);\n            continue;\n        }\n\n        position = tokenizer.call(self, value, 1);\n\n        if (position !== -1 && position < min) {\n            min = position;\n        }\n    }\n\n    subvalue = value.slice(0, min);\n    now = eat.now();\n\n    self.decode(subvalue, now, function (content, position, source) {\n        eat(source || content)(self.renderRaw(T_TEXT, content));\n    });\n}\n\n/**\n * Create a code-block node.\n *\n * @example\n *   renderCodeBlock('foo()', 'js', now());\n *\n * @param {string?} [value] - Code.\n * @param {string?} [language] - Optional language flag.\n * @param {Function} eat - Eater.\n * @return {Object} - `code` node.\n */\nfunction renderCodeBlock(value, language) {\n    return {\n        'type': T_CODE,\n        'lang': language || null,\n        'value': trimTrailingLines(value || EMPTY)\n    };\n}\n\n/**\n * Create a list-item using overly simple mechanics.\n *\n * @example\n *   renderPedanticListItem('- _foo_', now());\n *\n * @param {string} value - List-item.\n * @param {Object} position - List-item location.\n * @return {string} - Cleaned `value`.\n */\nfunction renderPedanticListItem(value, position) {\n    var self = this;\n    var indent = self.indent(position.line);\n\n    /**\n     * A simple replacer which removed all matches,\n     * and adds their length to `offset`.\n     *\n     * @param {string} $0 - Indentation to subtract.\n     * @return {string} - An empty string.\n     */\n    function replacer($0) {\n        indent($0.length);\n\n        return EMPTY;\n    }\n\n    /*\n     * Remove the list-items bullet.\n     */\n\n    value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);\n\n    /*\n     * The initial line was also matched by the below, so\n     * we reset the `line`.\n     */\n\n    indent = self.indent(position.line);\n\n    return value.replace(EXPRESSION_INITIAL_INDENT, replacer);\n}\n\n/**\n * Create a list-item using sane mechanics.\n *\n * @example\n *   renderNormalListItem('- _foo_', now());\n *\n * @param {string} value - List-item.\n * @param {Object} position - List-item location.\n * @return {string} - Cleaned `value`.\n */\nfunction renderNormalListItem(value, position) {\n    var self = this;\n    var indent = self.indent(position.line);\n    var max;\n    var bullet;\n    var rest;\n    var lines;\n    var trimmedLines;\n    var index;\n    var length;\n\n    /*\n     * Remove the list-items bullet.\n     */\n\n    value = value.replace(EXPRESSION_BULLET, function ($0, $1, $2, $3, $4) {\n        bullet = $1 + $2 + $3;\n        rest = $4;\n\n        /*\n         * Make sure that the first nine numbered list items\n         * can indent with an extra space.  That is, when\n         * the bullet did not receive an extra final space.\n         */\n\n        if (Number($2) < 10 && bullet.length % 2 === 1) {\n            $2 = C_SPACE + $2;\n        }\n\n        max = $1 + repeat(C_SPACE, $2.length) + $3;\n\n        return max + rest;\n    });\n\n    lines = value.split(C_NEWLINE);\n\n    trimmedLines = removeIndentation(\n        value, getIndent(max).indent\n    ).split(C_NEWLINE);\n\n    /*\n     * We replaced the initial bullet with something\n     * else above, which was used to trick\n     * `removeIndentation` into removing some more\n     * characters when possible. However, that could\n     * result in the initial line to be stripped more\n     * than it should be.\n     */\n\n    trimmedLines[0] = rest;\n\n    indent(bullet.length);\n\n    index = 0;\n    length = lines.length;\n\n    while (++index < length) {\n        indent(lines[index].length - trimmedLines[index].length);\n    }\n\n    return trimmedLines.join(C_NEWLINE);\n}\n\n/**\n * Create a list-item node.\n *\n * @example\n *   renderListItem('- _foo_', now());\n *\n * @param {Object} value - List-item.\n * @param {Object} position - List-item location.\n * @return {Object} - `listItem` node.\n */\nfunction renderListItem(value, position) {\n    var self = this;\n    var checked = null;\n    var node;\n    var task;\n    var indent;\n\n    value = LIST_ITEM_MAP[self.options.pedantic].apply(self, arguments);\n\n    if (self.options.gfm) {\n        task = value.match(EXPRESSION_TASK_ITEM);\n\n        if (task) {\n            indent = task[0].length;\n            checked = task[1].toLowerCase() === C_X_LOWER;\n\n            self.indent(position.line)(indent);\n            value = value.slice(indent);\n        }\n    }\n\n    node = {\n        'type': T_LIST_ITEM,\n        'loose': EXPRESSION_LOOSE_LIST_ITEM.test(value) ||\n            value.charAt(value.length - 1) === C_NEWLINE,\n        'checked': checked\n    };\n\n    node.children = self.tokenizeBlock(value, position);\n\n    return node;\n}\n\n/**\n * Create a footnote-definition node.\n *\n * @example\n *   renderFootnoteDefinition('1', '_foo_', now());\n *\n * @param {string} identifier - Unique reference.\n * @param {string} value - Contents\n * @param {Object} position - Definition location.\n * @return {Object} - `footnoteDefinition` node.\n */\nfunction renderFootnoteDefinition(identifier, value, position) {\n    var self = this;\n    var exitBlockquote = self.enterBlock();\n    var node;\n\n    node = {\n        'type': T_FOOTNOTE_DEFINITION,\n        'identifier': identifier,\n        'children': self.tokenizeBlock(value, position)\n    };\n\n    exitBlockquote();\n\n    return node;\n}\n\n/**\n * Create a heading node.\n *\n * @example\n *   renderHeading('_foo_', 1, now());\n *\n * @param {string} value - Content.\n * @param {number} depth - Heading depth.\n * @param {Object} position - Heading content location.\n * @return {Object} - `heading` node\n */\nfunction renderHeading(value, depth, position) {\n    return {\n        'type': T_HEADING,\n        'depth': depth,\n        'children': this.tokenizeInline(value, position)\n    };\n}\n\n/**\n * Create a blockquote node.\n *\n * @example\n *   renderBlockquote('_foo_', eat);\n *\n * @param {string} value - Content.\n * @param {Object} now - Position.\n * @return {Object} - `blockquote` node.\n */\nfunction renderBlockquote(value, now) {\n    var self = this;\n    var exitBlockquote = self.enterBlock();\n    var node = {\n        'type': T_BLOCKQUOTE,\n        'children': self.tokenizeBlock(value, now)\n    };\n\n    exitBlockquote();\n\n    return node;\n}\n\n/**\n * Create a void node.\n *\n * @example\n *   renderVoid('thematicBreak');\n *\n * @param {string} type - Node type.\n * @return {Object} - Node of type `type`.\n */\nfunction renderVoid(type) {\n    return {\n        'type': type\n    };\n}\n\n/**\n * Create a parent.\n *\n * @example\n *   renderParent('paragraph', '_foo_');\n *\n * @param {string} type - Node type.\n * @param {Array.<Object>} children - Child nodes.\n * @return {Object} - Node of type `type`.\n */\nfunction renderParent(type, children) {\n    return {\n        'type': type,\n        'children': children\n    };\n}\n\n/**\n * Create a raw node.\n *\n * @example\n *   renderRaw('inlineCode', 'foo()');\n *\n * @param {string} type - Node type.\n * @param {string} value - Contents.\n * @return {Object} - Node of type `type`.\n */\nfunction renderRaw(type, value) {\n    return {\n        'type': type,\n        'value': value\n    };\n}\n\n/**\n * Create a link node.\n *\n * @example\n *   renderLink(true, 'example.com', 'example', 'Example Domain', now(), eat);\n *   renderLink(false, 'fav.ico', 'example', 'Example Domain', now(), eat);\n *\n * @param {boolean} isLink - Whether linking to a document\n *   or an image.\n * @param {string} url - URI reference.\n * @param {string} content - Content.\n * @param {string?} title - Title.\n * @param {Object} position - Location of link.\n * @return {Object} - `link` or `image` node.\n */\nfunction renderLink(isLink, url, content, title, position) {\n    var self = this;\n    var exitLink = self.enterLink();\n    var node;\n\n    node = {\n        'type': isLink ? T_LINK : T_IMAGE,\n        'title': title || null\n    };\n\n    if (isLink) {\n        node.url = url;\n        node.children = self.tokenizeInline(content, position);\n    } else {\n        node.url = url;\n        node.alt = content ?\n            self.decode.raw(self.descape(content), position) :\n            null;\n    }\n\n    exitLink();\n\n    return node;\n}\n\n/**\n * Create a footnote node.\n *\n * @example\n *   renderFootnote('_foo_', now());\n *\n * @param {string} value - Contents.\n * @param {Object} position - Location of footnote.\n * @return {Object} - `footnote` node.\n */\nfunction renderFootnote(value, position) {\n    return this.renderInline(T_FOOTNOTE, value, position);\n}\n\n/**\n * Add a node with inline content.\n *\n * @example\n *   renderInline('strong', '_foo_', now());\n *\n * @param {string} type - Node type.\n * @param {string} value - Contents.\n * @param {Object} position - Location of node.\n * @return {Object} - Node of type `type`.\n */\nfunction renderInline(type, value, position) {\n    return this.renderParent(type, this.tokenizeInline(value, position));\n}\n\n/**\n * Add a node with block content.\n *\n * @example\n *   renderBlock('blockquote', 'Foo.', now());\n *\n * @param {string} type - Node type.\n * @param {string} value - Contents.\n * @param {Object} position - Location of node.\n * @return {Object} - Node of type `type`.\n */\nfunction renderBlock(type, value, position) {\n    return this.renderParent(type, this.tokenizeBlock(value, position));\n}\n\n/**\n * Find a possible escape sequence.\n *\n * @example\n *   locateEscape('foo \\- bar'); // 4\n *\n * @param {string} value - Value to search.\n * @param {number} fromIndex - Index to start searching at.\n * @return {number} - Location of possible escape sequence.\n */\nfunction locateEscape(value, fromIndex) {\n    return value.indexOf(C_BACKSLASH, fromIndex);\n}\n\n/**\n * Tokenise an escape sequence.\n *\n * @example\n *   tokenizeEscape(eat, '\\\\a');\n *\n * @property {Function} locator - Escape locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `text` or `break` node.\n */\nfunction tokenizeEscape(eat, value, silent) {\n    var self = this;\n    var character;\n\n    if (value.charAt(0) === C_BACKSLASH) {\n        character = value.charAt(1);\n\n        if (self.escape.indexOf(character) !== -1) {\n            /* istanbul ignore if - never used (yet) */\n            if (silent) {\n                return true;\n            }\n\n            return eat(C_BACKSLASH + character)(\n                character === C_NEWLINE ?\n                    self.renderVoid(T_BREAK) :\n                    self.renderRaw(T_TEXT, character)\n            );\n        }\n    }\n}\n\ntokenizeEscape.locator = locateEscape;\n\n/**\n * Find a possible auto-link.\n *\n * @example\n *   locateAutoLink('foo <bar'); // 4\n *\n * @param {string} value - Value to search.\n * @param {number} fromIndex - Index to start searching at.\n * @return {number} - Location of possible auto-link.\n */\nfunction locateAutoLink(value, fromIndex) {\n    return value.indexOf(C_LT, fromIndex);\n}\n\n/**\n * Tokenise a URL in carets.\n *\n * @example\n *   tokenizeAutoLink(eat, '<http://foo.bar>');\n *\n * @property {boolean} notInLink\n * @property {Function} locator - Auto-link locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `link` node.\n */\nfunction tokenizeAutoLink(eat, value, silent) {\n    var self;\n    var subvalue;\n    var length;\n    var index;\n    var queue;\n    var character;\n    var hasAtCharacter;\n    var link;\n    var now;\n    var content;\n    var tokenize;\n    var node;\n\n    if (value.charAt(0) !== C_LT) {\n        return;\n    }\n\n    self = this;\n    subvalue = EMPTY;\n    length = value.length;\n    index = 0;\n    queue = EMPTY;\n    hasAtCharacter = false;\n    link = EMPTY;\n\n    index++;\n    subvalue = C_LT;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (\n            character === C_SPACE ||\n            character === C_GT ||\n            character === C_AT_SIGN ||\n            (character === C_COLON && value.charAt(index + 1) === C_SLASH)\n        ) {\n            break;\n        }\n\n        queue += character;\n        index++;\n    }\n\n    if (!queue) {\n        return;\n    }\n\n    link += queue;\n    queue = EMPTY;\n\n    character = value.charAt(index);\n    link += character;\n    index++;\n\n    if (character === C_AT_SIGN) {\n        hasAtCharacter = true;\n    } else {\n        if (\n            character !== C_COLON ||\n            value.charAt(index + 1) !== C_SLASH\n        ) {\n            return;\n        }\n\n        link += C_SLASH;\n        index++;\n    }\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character === C_SPACE || character === C_GT) {\n            break;\n        }\n\n        queue += character;\n        index++;\n    }\n\n    character = value.charAt(index);\n\n    if (!queue || character !== C_GT) {\n        return;\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n        return true;\n    }\n\n    link += queue;\n    content = link;\n    subvalue += link + character;\n    now = eat.now();\n    now.column++;\n    now.offset++;\n\n    if (hasAtCharacter) {\n        if (\n            link.substr(0, MAILTO_PROTOCOL.length).toLowerCase() !==\n            MAILTO_PROTOCOL\n        ) {\n            link = MAILTO_PROTOCOL + link;\n        } else {\n            content = content.substr(MAILTO_PROTOCOL.length);\n            now.column += MAILTO_PROTOCOL.length;\n            now.offset += MAILTO_PROTOCOL.length;\n        }\n    }\n\n    /*\n     * Temporarily remove support for escapes in autolinks.\n     */\n\n    tokenize = self.inlineTokenizers.escape;\n    self.inlineTokenizers.escape = null;\n\n    node = eat(subvalue)(\n        self.renderLink(true, decode(link), content, null, now, eat)\n    );\n\n    self.inlineTokenizers.escape = tokenize;\n\n    return node;\n}\n\ntokenizeAutoLink.notInLink = true;\ntokenizeAutoLink.locator = locateAutoLink;\n\n/**\n * Find a possible URL.\n *\n * @example\n *   locateURL('foo http://bar'); // 4\n *\n * @param {string} value - Value to search.\n * @param {number} fromIndex - Index to start searching at.\n * @return {number} - Location of possible URL.\n */\nfunction locateURL(value, fromIndex) {\n    var index = -1;\n    var min = -1;\n    var position;\n\n    if (!this.options.gfm) {\n        return -1;\n    }\n\n    while (++index < PROTOCOLS_LENGTH) {\n        position = value.indexOf(PROTOCOLS[index], fromIndex);\n\n        if (position !== -1 && (position < min || min === -1)) {\n            min = position;\n        }\n    }\n\n    return min;\n}\n\n/**\n * Tokenise a URL in text.\n *\n * @example\n *   tokenizeURL(eat, 'http://foo.bar');\n *\n * @property {boolean} notInLink\n * @property {Function} locator - URL locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `link` node.\n */\nfunction tokenizeURL(eat, value, silent) {\n    var self = this;\n    var subvalue;\n    var content;\n    var character;\n    var index;\n    var position;\n    var protocol;\n    var match;\n    var length;\n    var queue;\n    var parenCount;\n    var nextCharacter;\n    var now;\n\n    if (!self.options.gfm) {\n        return;\n    }\n\n    subvalue = EMPTY;\n    index = -1;\n    length = PROTOCOLS_LENGTH;\n\n    while (++index < length) {\n        protocol = PROTOCOLS[index];\n        match = value.slice(0, protocol.length);\n\n        if (match.toLowerCase() === protocol) {\n            subvalue = match;\n            break;\n        }\n    }\n\n    if (!subvalue) {\n        return;\n    }\n\n    index = subvalue.length;\n    length = value.length;\n    queue = EMPTY;\n    parenCount = 0;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (isWhiteSpace(character) || character === C_LT) {\n            break;\n        }\n\n        if (\n            character === C_DOT ||\n            character === C_COMMA ||\n            character === C_COLON ||\n            character === C_SEMI_COLON ||\n            character === C_DOUBLE_QUOTE ||\n            character === C_SINGLE_QUOTE ||\n            character === C_PAREN_CLOSE ||\n            character === C_BRACKET_CLOSE\n        ) {\n            nextCharacter = value.charAt(index + 1);\n\n            if (\n                !nextCharacter ||\n                isWhiteSpace(nextCharacter)\n            ) {\n                break;\n            }\n        }\n\n        if (\n            character === C_PAREN_OPEN ||\n            character === C_BRACKET_OPEN\n        ) {\n            parenCount++;\n        }\n\n        if (\n            character === C_PAREN_CLOSE ||\n            character === C_BRACKET_CLOSE\n        ) {\n            parenCount--;\n\n            if (parenCount < 0) {\n                break;\n            }\n        }\n\n        queue += character;\n        index++;\n    }\n\n    if (!queue) {\n        return;\n    }\n\n    subvalue += queue;\n    content = subvalue;\n\n    if (protocol === MAILTO_PROTOCOL) {\n        position = queue.indexOf(C_AT_SIGN);\n\n        if (position === -1 || position === length - 1) {\n            return;\n        }\n\n        content = content.substr(MAILTO_PROTOCOL.length);\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n        return true;\n    }\n\n    now = eat.now();\n\n    return eat(subvalue)(\n        self.renderLink(true, decode(subvalue), content, null, now, eat)\n    );\n}\n\ntokenizeURL.notInLink = true;\ntokenizeURL.locator = locateURL;\n\n/**\n * Find a possible tag.\n *\n * @example\n *   locateTag('foo <bar'); // 4\n *\n * @param {string} value - Value to search.\n * @param {number} fromIndex - Index to start searching at.\n * @return {number} - Location of possible tag.\n */\nfunction locateTag(value, fromIndex) {\n    return value.indexOf(C_LT, fromIndex);\n}\n\n/**\n * Tokenise an HTML tag.\n *\n * @example\n *   tokenizeInlineHTML(eat, '<span foo=\"bar\">');\n *\n * @property {Function} locator - Tag locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `html` node.\n */\nfunction tokenizeInlineHTML(eat, value, silent) {\n    var self = this;\n    var subvalue = eatHTMLComment(value, self.options) ||\n        eatHTMLCDATA(value) ||\n        eatHTMLProcessingInstruction(value) ||\n        eatHTMLDeclaration(value) ||\n        eatHTMLClosingTag(value) ||\n        eatHTMLOpeningTag(value);\n\n    if (!subvalue) {\n        return;\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n        return true;\n    }\n\n    if (!self.inLink && EXPRESSION_HTML_LINK_OPEN.test(subvalue)) {\n        self.inLink = true;\n    } else if (self.inLink && EXPRESSION_HTML_LINK_CLOSE.test(subvalue)) {\n        self.inLink = false;\n    }\n\n    return eat(subvalue)(self.renderRaw(T_HTML, subvalue));\n}\n\ntokenizeInlineHTML.locator = locateTag;\n\n/**\n * Find a possible link.\n *\n * @example\n *   locateLink('foo ![bar'); // 4\n *\n * @param {string} value - Value to search.\n * @param {number} fromIndex - Index to start searching at.\n * @return {number} - Location of possible link.\n */\nfunction locateLink(value, fromIndex) {\n    var link = value.indexOf(C_BRACKET_OPEN, fromIndex);\n    var image = value.indexOf(C_EXCLAMATION_MARK + C_BRACKET_OPEN, fromIndex);\n\n    if (image === -1) {\n        return link;\n    }\n\n    /*\n     * Link can never be `-1` if an image is found, so we dont need to\n     * check for that :)\n     */\n\n    return link < image ? link : image;\n}\n\n/**\n * Tokenise a link.\n *\n * @example\n *   tokenizeLink(eat, '![foo](fav.ico \"Favicon\"));\n *\n * @property {Function} locator - Link locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `link` or `image` node.\n */\nfunction tokenizeLink(eat, value, silent) {\n    var self = this;\n    var subvalue = EMPTY;\n    var index = 0;\n    var character = value.charAt(0);\n    var commonmark = self.options.commonmark;\n    var gfm = self.options.gfm;\n    var closed;\n    var count;\n    var opening;\n    var beforeURL;\n    var beforeTitle;\n    var subqueue;\n    var openCount;\n    var hasMarker;\n    var markers;\n    var isImage;\n    var content;\n    var marker;\n    var length;\n    var title;\n    var depth;\n    var queue;\n    var url;\n    var now;\n\n    /*\n     * Detect whether this is an image.\n     */\n\n    if (character === C_EXCLAMATION_MARK) {\n        isImage = true;\n        subvalue = character;\n        character = value.charAt(++index);\n    }\n\n    /*\n     * Eat the opening.\n     */\n\n    if (character !== C_BRACKET_OPEN) {\n        return;\n    }\n\n    /*\n     * Exit when this is a link and were already inside\n     * a link.\n     */\n\n    if (!isImage && self.inLink) {\n        return;\n    }\n\n    subvalue += character;\n    queue = EMPTY;\n    index++;\n\n    /*\n     * Eat the content.\n     */\n\n    length = value.length;\n    now = eat.now();\n    depth = 0;\n\n    now.column += index;\n    now.offset += index;\n\n    while (index < length) {\n        subqueue = character = value.charAt(index);\n\n        if (character === C_TICK) {\n            /* Inline-code in link content. */\n            count = 1;\n\n            while (value.charAt(index + 1) === C_TICK) {\n                subqueue += character;\n                index++;\n                count++;\n            }\n\n            if (!opening) {\n                opening = count;\n            } else if (count >= opening) {\n                opening = 0;\n            }\n        } else if (character === C_BACKSLASH) {\n            /* Allow brackets to be escaped. */\n            index++;\n            subqueue += value.charAt(index);\n        /* In GFM mode, brackets in code still count.\n         * In all other modes, they dont.  This empty\n         * block prevents the next statements are\n         * entered. */\n        } else if ((!opening || gfm) && character === C_BRACKET_OPEN) {\n            depth++;\n        } else if ((!opening || gfm) && character === C_BRACKET_CLOSE) {\n            if (depth) {\n                depth--;\n            } else {\n                /* Allow white-space between content and\n                 * url in GFM mode. */\n                if (gfm) {\n                    while (index < length) {\n                        character = value.charAt(index + 1);\n\n                        if (!isWhiteSpace(character)) {\n                            break;\n                        }\n\n                        subqueue += character;\n                        index++;\n                    }\n                }\n\n                if (value.charAt(index + 1) !== C_PAREN_OPEN) {\n                    return;\n                }\n\n                subqueue += C_PAREN_OPEN;\n                closed = true;\n                index++;\n\n                break;\n            }\n        }\n\n        queue += subqueue;\n        subqueue = EMPTY;\n        index++;\n    }\n\n    /* Eat the content closing. */\n    if (!closed) {\n        return;\n    }\n\n    content = queue;\n    subvalue += queue + subqueue;\n    index++;\n\n    /*\n     * Eat white-space.\n     */\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (!isWhiteSpace(character)) {\n            break;\n        }\n\n        subvalue += character;\n        index++;\n    }\n\n    /*\n     * Eat the URL.\n     */\n\n    character = value.charAt(index);\n    markers = commonmark ? COMMONMARK_LINK_MARKERS : LINK_MARKERS;\n    openCount = 0;\n    queue = EMPTY;\n    beforeURL = subvalue;\n\n    if (character === C_LT) {\n        index++;\n        beforeURL += C_LT;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (character === C_GT) {\n                break;\n            }\n\n            if (commonmark && character === C_NEWLINE) {\n                return;\n            }\n\n            queue += character;\n            index++;\n        }\n\n        if (value.charAt(index) !== C_GT) {\n            return;\n        }\n\n        subvalue += C_LT + queue + C_GT;\n        url = queue;\n        index++;\n    } else {\n        character = null;\n        subqueue = EMPTY;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (subqueue && has.call(markers, character)) {\n                break;\n            }\n\n            if (isWhiteSpace(character)) {\n                if (commonmark) {\n                    break;\n                }\n\n                subqueue += character;\n            } else {\n                if (character === C_PAREN_OPEN) {\n                    depth++;\n                    openCount++;\n                } else if (character === C_PAREN_CLOSE) {\n                    if (depth === 0) {\n                        break;\n                    }\n\n                    depth--;\n                }\n\n                queue += subqueue;\n                subqueue = EMPTY;\n\n                if (character === C_BACKSLASH) {\n                    queue += C_BACKSLASH;\n                    character = value.charAt(++index);\n                }\n\n                queue += character;\n            }\n\n            index++;\n        }\n\n        subvalue += queue;\n        url = queue;\n        index = subvalue.length;\n    }\n\n    /*\n     * Eat white-space.\n     */\n\n    queue = EMPTY;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (!isWhiteSpace(character)) {\n            break;\n        }\n\n        queue += character;\n        index++;\n    }\n\n    character = value.charAt(index);\n    subvalue += queue;\n\n    /*\n     * Eat the title.\n     */\n\n    if (queue && has.call(markers, character)) {\n        index++;\n        subvalue += character;\n        queue = EMPTY;\n        marker = markers[character];\n        beforeTitle = subvalue;\n\n        /*\n         * In commonmark-mode, things are pretty easy: the\n         * marker cannot occur inside the title.\n         *\n         * Non-commonmark does, however, support nested\n         * delimiters.\n         */\n\n        if (commonmark) {\n            while (index < length) {\n                character = value.charAt(index);\n\n                if (character === marker) {\n                    break;\n                }\n\n                if (character === C_BACKSLASH) {\n                    queue += C_BACKSLASH;\n                    character = value.charAt(++index);\n                }\n\n                index++;\n                queue += character;\n            }\n\n            character = value.charAt(index);\n\n            if (character !== marker) {\n                return;\n            }\n\n            title = queue;\n            subvalue += queue + character;\n            index++;\n\n            while (index < length) {\n                character = value.charAt(index);\n\n                if (!isWhiteSpace(character)) {\n                    break;\n                }\n\n                subvalue += character;\n                index++;\n            }\n        } else {\n            subqueue = EMPTY;\n\n            while (index < length) {\n                character = value.charAt(index);\n\n                if (character === marker) {\n                    if (hasMarker) {\n                        queue += marker + subqueue;\n                        subqueue = EMPTY;\n                    }\n\n                    hasMarker = true;\n                } else if (!hasMarker) {\n                    queue += character;\n                } else if (character === C_PAREN_CLOSE) {\n                    subvalue += queue + marker + subqueue;\n                    title = queue;\n                    break;\n                } else if (isWhiteSpace(character)) {\n                    subqueue += character;\n                } else {\n                    queue += marker + subqueue + character;\n                    subqueue = EMPTY;\n                    hasMarker = false;\n                }\n\n                index++;\n            }\n        }\n    }\n\n    if (value.charAt(index) !== C_PAREN_CLOSE) {\n        return;\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n        return true;\n    }\n\n    subvalue += C_PAREN_CLOSE;\n\n    url = self.decode.raw(self.descape(url), eat(beforeURL).test().end);\n\n    if (title) {\n        beforeTitle = eat(beforeTitle).test().end;\n        title = self.decode.raw(self.descape(title), beforeTitle);\n    }\n\n    return eat(subvalue)(\n        self.renderLink(!isImage, url, content, title, now, eat)\n    );\n}\n\ntokenizeLink.locator = locateLink;\n\n/**\n * Tokenise a reference link, image, or footnote;\n * shortcut reference link, or footnote.\n *\n * @example\n *   tokenizeReference(eat, '[foo]');\n *   tokenizeReference(eat, '[foo][]');\n *   tokenizeReference(eat, '[foo][bar]');\n *\n * @property {Function} locator - Reference locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - Reference node.\n */\nfunction tokenizeReference(eat, value, silent) {\n    var self = this;\n    var character = value.charAt(0);\n    var index = 0;\n    var length = value.length;\n    var subvalue = EMPTY;\n    var intro = EMPTY;\n    var type = T_LINK;\n    var referenceType = REFERENCE_TYPE_SHORTCUT;\n    var content;\n    var identifier;\n    var now;\n    var node;\n    var exitLink;\n    var queue;\n    var bracketed;\n    var depth;\n\n    /*\n     * Check whether were eating an image.\n     */\n\n    if (character === C_EXCLAMATION_MARK) {\n        type = T_IMAGE;\n        intro = character;\n        character = value.charAt(++index);\n    }\n\n    if (character !== C_BRACKET_OPEN) {\n        return;\n    }\n\n    index++;\n    intro += character;\n    queue = EMPTY;\n\n    /*\n     * Check whether were eating a footnote.\n     */\n\n    if (\n        self.options.footnotes &&\n        type === T_LINK &&\n        value.charAt(index) === C_CARET\n    ) {\n        intro += C_CARET;\n        index++;\n        type = T_FOOTNOTE;\n    }\n\n    /*\n     * Eat the text.\n     */\n\n    depth = 0;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (character === C_BRACKET_OPEN) {\n            bracketed = true;\n            depth++;\n        } else if (character === C_BRACKET_CLOSE) {\n            if (!depth) {\n                break;\n            }\n\n            depth--;\n        }\n\n        if (character === C_BACKSLASH) {\n            queue += C_BACKSLASH;\n            character = value.charAt(++index);\n        }\n\n        queue += character;\n        index++;\n    }\n\n    subvalue = content = queue;\n    character = value.charAt(index);\n\n    if (character !== C_BRACKET_CLOSE) {\n        return;\n    }\n\n    index++;\n    subvalue += character;\n    queue = EMPTY;\n\n    while (index < length) {\n        character = value.charAt(index);\n\n        if (!isWhiteSpace(character)) {\n            break;\n        }\n\n        queue += character;\n        index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character !== C_BRACKET_OPEN) {\n        if (!content) {\n            return;\n        }\n\n        identifier = content;\n    } else {\n        identifier = EMPTY;\n        queue += character;\n        index++;\n\n        while (index < length) {\n            character = value.charAt(index);\n\n            if (\n                character === C_BRACKET_OPEN ||\n                character === C_BRACKET_CLOSE\n            ) {\n                break;\n            }\n\n            if (character === C_BACKSLASH) {\n                identifier += C_BACKSLASH;\n                character = value.charAt(++index);\n            }\n\n            identifier += character;\n            index++;\n        }\n\n        character = value.charAt(index);\n\n        if (character === C_BRACKET_CLOSE) {\n            queue += identifier + character;\n            index++;\n\n            referenceType = identifier ?\n                REFERENCE_TYPE_FULL :\n                REFERENCE_TYPE_COLLAPSED;\n        } else {\n            identifier = EMPTY;\n        }\n\n        subvalue += queue;\n        queue = EMPTY;\n    }\n\n    /*\n     * Brackets cannot be inside the identifier.\n     */\n\n    if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {\n        return;\n    }\n\n    /*\n     * Inline footnotes cannot have an identifier.\n     */\n\n    if (type === T_FOOTNOTE && referenceType !== REFERENCE_TYPE_SHORTCUT) {\n        type = T_LINK;\n        intro = C_BRACKET_OPEN + C_CARET;\n        content = C_CARET + content;\n    }\n\n    subvalue = intro + subvalue;\n\n    if (type === T_LINK && self.inLink) {\n        return null;\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n        return true;\n    }\n\n    if (type === T_FOOTNOTE && content.indexOf(C_SPACE) !== -1) {\n        return eat(subvalue)(self.renderFootnote(content, eat.now()));\n    }\n\n    now = eat.now();\n    now.column += intro.length;\n    now.offset += intro.length;\n    identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : content;\n\n    node = {\n        'type': type + 'Reference',\n        'identifier': normalize(identifier)\n    };\n\n    if (type === T_LINK || type === T_IMAGE) {\n        node.referenceType = referenceType;\n    }\n\n    if (type === T_LINK) {\n        exitLink = self.enterLink();\n        node.children = self.tokenizeInline(content, now);\n        exitLink();\n    } else if (type === T_IMAGE) {\n        node.alt = self.decode.raw(self.descape(content), now) || null;\n    }\n\n    return eat(subvalue)(node);\n}\n\ntokenizeReference.locator = locateLink;\n\n/**\n * Find a possible strong emphasis.\n *\n * @example\n *   locateStrong('foo **bar'); // 4\n *\n * @param {string} value - Value to search.\n * @param {number} fromIndex - Index to start searching at.\n * @return {number} - Location of possible strong emphasis.\n */\nfunction locateStrong(value, fromIndex) {\n    var asterisk = value.indexOf(C_ASTERISK + C_ASTERISK, fromIndex);\n    var underscore = value.indexOf(C_UNDERSCORE + C_UNDERSCORE, fromIndex);\n\n    if (underscore === -1) {\n        return asterisk;\n    }\n\n    if (asterisk === -1) {\n        return underscore;\n    }\n\n    return underscore < asterisk ? underscore : asterisk;\n}\n\n/**\n * Tokenise strong emphasis.\n *\n * @example\n *   tokenizeStrong(eat, '**foo**');\n *   tokenizeStrong(eat, '__foo__');\n *\n * @property {Function} locator - Strong emphasis locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `strong` node.\n */\nfunction tokenizeStrong(eat, value, silent) {\n    var self = this;\n    var index = 0;\n    var character = value.charAt(index);\n    var now;\n    var pedantic;\n    var marker;\n    var queue;\n    var subvalue;\n    var length;\n    var prev;\n\n    if (\n        EMPHASIS_MARKERS[character] !== true ||\n        value.charAt(++index) !== character\n    ) {\n        return;\n    }\n\n    pedantic = self.options.pedantic;\n    marker = character;\n    subvalue = marker + marker;\n    length = value.length;\n    index++;\n    queue = character = EMPTY;\n\n    if (pedantic && isWhiteSpace(value.charAt(index))) {\n        return;\n    }\n\n    while (index < length) {\n        prev = character;\n        character = value.charAt(index);\n\n        if (\n            character === marker &&\n            value.charAt(index + 1) === marker &&\n            (!pedantic || !isWhiteSpace(prev))\n        ) {\n            character = value.charAt(index + 2);\n\n            if (character !== marker) {\n                if (!trim(queue)) {\n                    return;\n                }\n\n                /* istanbul ignore if - never used (yet) */\n                if (silent) {\n                    return true;\n                }\n\n                now = eat.now();\n                now.column += 2;\n                now.offset += 2;\n\n                return eat(subvalue + queue + subvalue)(\n                    self.renderInline(T_STRONG, queue, now)\n                );\n            }\n        }\n\n        if (!pedantic && character === C_BACKSLASH) {\n            queue += character;\n            character = value.charAt(++index);\n        }\n\n        queue += character;\n        index++;\n    }\n}\n\ntokenizeStrong.locator = locateStrong;\n\n/**\n * Find possible slight emphasis.\n *\n * @example\n *   locateEmphasis('foo *bar'); // 4\n *\n * @param {string} value - Value to search.\n * @param {number} fromIndex - Index to start searching at.\n * @return {number} - Location of possible slight emphasis.\n */\nfunction locateEmphasis(value, fromIndex) {\n    var asterisk = value.indexOf(C_ASTERISK, fromIndex);\n    var underscore = value.indexOf(C_UNDERSCORE, fromIndex);\n\n    if (underscore === -1) {\n        return asterisk;\n    }\n\n    if (asterisk === -1) {\n        return underscore;\n    }\n\n    return underscore < asterisk ? underscore : asterisk;\n}\n\n/**\n * Tokenise slight emphasis.\n *\n * @example\n *   tokenizeEmphasis(eat, '*foo*');\n *   tokenizeEmphasis(eat, '_foo_');\n *\n * @property {Function} locator - Slight emphasis locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `emphasis` node.\n */\nfunction tokenizeEmphasis(eat, value, silent) {\n    var self = this;\n    var index = 0;\n    var character = value.charAt(index);\n    var now;\n    var pedantic;\n    var marker;\n    var queue;\n    var subvalue;\n    var length;\n    var prev;\n\n    if (EMPHASIS_MARKERS[character] !== true) {\n        return;\n    }\n\n    pedantic = self.options.pedantic;\n    subvalue = marker = character;\n    length = value.length;\n    index++;\n    queue = character = EMPTY;\n\n    if (pedantic && isWhiteSpace(value.charAt(index))) {\n        return;\n    }\n\n    while (index < length) {\n        prev = character;\n        character = value.charAt(index);\n\n        if (\n            character === marker &&\n            (!pedantic || !isWhiteSpace(prev))\n        ) {\n            character = value.charAt(++index);\n\n            if (character !== marker) {\n                if (!trim(queue) || prev === marker) {\n                    return;\n                }\n\n                if (\n                    pedantic ||\n                    marker !== C_UNDERSCORE ||\n                    !isWordCharacter(character)\n                ) {\n                    /* istanbul ignore if - never used (yet) */\n                    if (silent) {\n                        return true;\n                    }\n\n                    now = eat.now();\n                    now.column++;\n                    now.offset++;\n\n                    return eat(subvalue + queue + marker)(\n                        self.renderInline(T_EMPHASIS, queue, now)\n                    );\n                }\n            }\n\n            queue += marker;\n        }\n\n        if (!pedantic && character === C_BACKSLASH) {\n            queue += character;\n            character = value.charAt(++index);\n        }\n\n        queue += character;\n        index++;\n    }\n}\n\ntokenizeEmphasis.locator = locateEmphasis;\n\n/**\n * Find a possible deletion.\n *\n * @example\n *   locateDeletion('foo ~~bar'); // 4\n *\n * @param {string} value - Value to search.\n * @param {number} fromIndex - Index to start searching at.\n * @return {number} - Location of possible deletion.\n */\nfunction locateDeletion(value, fromIndex) {\n    return value.indexOf(C_TILDE + C_TILDE, fromIndex);\n}\n\n/**\n * Tokenise a deletion.\n *\n * @example\n *   tokenizeDeletion(eat, '~~foo~~');\n *\n * @property {Function} locator - Deletion locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `delete` node.\n */\nfunction tokenizeDeletion(eat, value, silent) {\n    var self = this;\n    var character = EMPTY;\n    var previous = EMPTY;\n    var preceding = EMPTY;\n    var subvalue = EMPTY;\n    var index;\n    var length;\n    var now;\n\n    if (\n        !self.options.gfm ||\n        value.charAt(0) !== C_TILDE ||\n        value.charAt(1) !== C_TILDE ||\n        isWhiteSpace(value.charAt(2))\n    ) {\n        return;\n    }\n\n    index = 1;\n    length = value.length;\n    now = eat.now();\n    now.column += 2;\n    now.offset += 2;\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (\n            character === C_TILDE &&\n            previous === C_TILDE &&\n            (!preceding || !isWhiteSpace(preceding))\n        ) {\n            /* istanbul ignore if - never used (yet) */\n            if (silent) {\n                return true;\n            }\n\n            return eat(C_TILDE + C_TILDE + subvalue + C_TILDE + C_TILDE)(\n                self.renderInline(T_DELETE, subvalue, now)\n            );\n        }\n\n        subvalue += previous;\n        preceding = previous;\n        previous = character;\n    }\n}\n\ntokenizeDeletion.locator = locateDeletion;\n\n/**\n * Find possible inline code.\n *\n * @example\n *   locateInlineCode('foo `bar'); // 4\n *\n * @param {string} value - Value to search.\n * @param {number} fromIndex - Index to start searching at.\n * @return {number} - Location of possible inline code.\n */\nfunction locateInlineCode(value, fromIndex) {\n    return value.indexOf(C_TICK, fromIndex);\n}\n\n/**\n * Tokenise inline code.\n *\n * @example\n *   tokenizeInlineCode(eat, '`foo()`');\n *\n * @property {Function} locator - Inline code locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `inlineCode` node.\n */\nfunction tokenizeInlineCode(eat, value, silent) {\n    var self = this;\n    var length = value.length;\n    var index = 0;\n    var queue = EMPTY;\n    var tickQueue = EMPTY;\n    var contentQueue;\n    var subqueue;\n    var count;\n    var openingCount;\n    var subvalue;\n    var character;\n    var found;\n    var next;\n\n    while (index < length) {\n        if (value.charAt(index) !== C_TICK) {\n            break;\n        }\n\n        queue += C_TICK;\n        index++;\n    }\n\n    if (!queue) {\n        return;\n    }\n\n    subvalue = queue;\n    openingCount = index;\n    queue = EMPTY;\n    next = value.charAt(index);\n    count = 0;\n\n    while (index < length) {\n        character = next;\n        next = value.charAt(index + 1);\n\n        if (character === C_TICK) {\n            count++;\n            tickQueue += character;\n        } else {\n            count = 0;\n            queue += character;\n        }\n\n        if (count && next !== C_TICK) {\n            if (count === openingCount) {\n                subvalue += queue + tickQueue;\n                found = true;\n                break;\n            }\n\n            queue += tickQueue;\n            tickQueue = EMPTY;\n        }\n\n        index++;\n    }\n\n    if (!found) {\n        if (openingCount % 2 !== 0) {\n            return;\n        }\n\n        queue = EMPTY;\n    }\n\n    /* istanbul ignore if - never used (yet) */\n    if (silent) {\n        return true;\n    }\n\n    contentQueue = subqueue = EMPTY;\n    length = queue.length;\n    index = -1;\n\n    while (++index < length) {\n        character = queue.charAt(index);\n\n        if (isWhiteSpace(character)) {\n            subqueue += character;\n            continue;\n        }\n\n        if (subqueue) {\n            if (contentQueue) {\n                contentQueue += subqueue;\n            }\n\n            subqueue = EMPTY;\n        }\n\n        contentQueue += character;\n    }\n\n    return eat(subvalue)(self.renderRaw(T_INLINE_CODE, contentQueue));\n}\n\ntokenizeInlineCode.locator = locateInlineCode;\n\n/**\n * Find a possible break.\n *\n * @example\n *   locateBreak('foo   \\nbar'); // 3\n *\n * @param {string} value - Value to search.\n * @param {number} fromIndex - Index to start searching at.\n * @return {number} - Location of possible break.\n */\nfunction locateBreak(value, fromIndex) {\n    var index = value.indexOf(C_NEWLINE, fromIndex);\n\n    while (index > fromIndex) {\n        if (value.charAt(index - 1) !== C_SPACE) {\n            break;\n        }\n\n        index--;\n    }\n\n    return index;\n}\n\n/**\n * Tokenise a break.\n *\n * @example\n *   tokenizeBreak(eat, '  \\n');\n *\n * @property {Function} locator - Break locator.\n * @param {function(string)} eat - Eater.\n * @param {string} value - Rest of content.\n * @param {boolean?} [silent] - Whether this is a dry run.\n * @return {Node?|boolean} - `break` node.\n */\nfunction tokenizeBreak(eat, value, silent) {\n    var self = this;\n    var breaks = self.options.breaks;\n    var length = value.length;\n    var index = -1;\n    var queue = EMPTY;\n    var character;\n\n    while (++index < length) {\n        character = value.charAt(index);\n\n        if (character === C_NEWLINE) {\n            if (!breaks && index < MIN_BREAK_LENGTH) {\n                return;\n            }\n\n            /* istanbul ignore if - never used (yet) */\n            if (silent) {\n                return true;\n            }\n\n            queue += character;\n            return eat(queue)(self.renderVoid(T_BREAK));\n        }\n\n        if (character !== C_SPACE) {\n            return;\n        }\n\n        queue += character;\n    }\n}\n\ntokenizeBreak.locator = locateBreak;\n\n/**\n * Construct a new parser.\n *\n * @example\n *   var parser = new Parser(new VFile('Foo'));\n *\n * @constructor\n * @class {Parser}\n * @param {VFile} file - File to parse.\n * @param {Object?} [options] - Passed to\n *   `Parser#setOptions()`.\n */\nfunction Parser(file, options) {\n    var self = this;\n\n    self.file = file;\n    self.inLink = false;\n    self.inBlock = false;\n    self.inList = false;\n    self.atStart = true;\n    self.toOffset = vfileLocation(file).toOffset;\n\n    self.descape = descapeFactory(self, 'escape');\n    self.decode = decodeFactory(self);\n\n    self.options = extend({}, self.options);\n\n    self.setOptions(options);\n}\n\n/**\n * Set options.  Does not overwrite previously set\n * options.\n *\n * @example\n *   var parser = new Parser();\n *   parser.setOptions({gfm: true});\n *\n * @this {Parser}\n * @throws {Error} - When an option is invalid.\n * @param {Object?} [options] - Parse settings.\n * @return {Parser} - `self`.\n */\nParser.prototype.setOptions = function (options) {\n    var self = this;\n    var current = self.options;\n    var key;\n\n    if (options === null || options === undefined) {\n        options = {};\n    } else if (typeof options === 'object') {\n        options = extend({}, options);\n    } else {\n        throw new Error(\n            'Invalid value `' + options + '` ' +\n            'for setting `options`'\n        );\n    }\n\n    for (key in defaultOptions) {\n        var value = options[key];\n\n        if (value === null || value === undefined) {\n            value = current[key];\n        }\n\n        if (typeof value !== 'boolean') {\n            throw new Error(\n                'Invalid value `' + value + '` ' +\n                'for setting `options.' + key + '`'\n            );\n        }\n\n        options[key] = value;\n    }\n\n    self.options = options;\n\n    if (options.commonmark) {\n        self.escape = escapes.commonmark;\n    } else if (options.gfm) {\n        self.escape = escapes.gfm;\n    } else {\n        self.escape = escapes.default;\n    }\n\n    return self;\n};\n\n/*\n * Expose `defaults`.\n */\n\nParser.prototype.options = defaultOptions;\n\n/**\n * Factory to track indentation for each line corresponding\n * to the given `start` and the number of invocations.\n *\n * @param {number} start - Starting line.\n * @return {function(offset)} - Indenter.\n */\nParser.prototype.indent = function (start) {\n    var self = this;\n    var line = start;\n\n    /**\n     * Intender which increments the global offset,\n     * starting at the bound line, and further incrementing\n     * each line for each invocation.\n     *\n     * @example\n     *   indenter(2);\n     *\n     * @param {number} offset - Number to increment the\n     *   offset.\n     */\n    function indenter(offset) {\n        self.offset[line] = (self.offset[line] || 0) + offset;\n\n        line++;\n    }\n\n    return indenter;\n};\n\n/**\n * Get found offsets starting at `start`.\n *\n * @param {number} start - Starting line.\n * @return {Array.<number>} - Offsets starting at `start`.\n */\nParser.prototype.getIndent = function (start) {\n    var offset = this.offset;\n    var result = [];\n\n    while (++start) {\n        if (!(start in offset)) {\n            break;\n        }\n\n        result.push((offset[start] || 0) + 1);\n    }\n\n    return result;\n};\n\n/**\n * Parse the bound file.\n *\n * @example\n *   new Parser(new File('_Foo_.')).parse();\n *\n * @this {Parser}\n * @return {Object} - `root` node.\n */\nParser.prototype.parse = function () {\n    var self = this;\n    var value = String(self.file);\n    var column = 1;\n    var node;\n\n    /*\n     * Clean non-unix newlines: `\\r\\n` and `\\r` are all\n     * changed to `\\n`.  This should not affect positional\n     * information.\n     */\n\n    value = value.replace(EXPRESSION_LINE_BREAKS, C_NEWLINE);\n\n    if (value.charCodeAt(0) === 0xFEFF) {\n        value = value.slice(1);\n        column++;\n        self.offset++;\n    }\n\n    /*\n     * Add an `offset` matrix, used to keep track of\n     * syntax and white space indentation per line.\n     */\n\n    self.offset = {};\n\n    node = self.renderBlock(T_ROOT, value, {\n        'line': 1,\n        'column': column\n    });\n\n    node.position = {\n        'start': {\n            'line': 1,\n            'column': 1,\n            'offset': 0\n        }\n    };\n\n    node.position.end = self.eof || extend({}, node.position.start);\n\n    if (!self.options.position) {\n        removePosition(node);\n    }\n\n    return node;\n};\n\n/*\n * Enter and exit helpers.\n */\n\nParser.prototype.exitStart = toggle('atStart', true);\nParser.prototype.enterList = toggle('inList', false);\nParser.prototype.enterLink = toggle('inLink', false);\nParser.prototype.enterBlock = toggle('inBlock', false);\n\n/*\n * Expose helpers\n */\n\nParser.prototype.renderRaw = renderRaw;\nParser.prototype.renderVoid = renderVoid;\nParser.prototype.renderParent = renderParent;\nParser.prototype.renderInline = renderInline;\nParser.prototype.renderBlock = renderBlock;\n\nParser.prototype.renderLink = renderLink;\nParser.prototype.renderCodeBlock = renderCodeBlock;\nParser.prototype.renderBlockquote = renderBlockquote;\nParser.prototype.renderListItem = renderListItem;\nParser.prototype.renderFootnoteDefinition = renderFootnoteDefinition;\nParser.prototype.renderHeading = renderHeading;\nParser.prototype.renderFootnote = renderFootnote;\n\n/**\n * Construct a tokenizer.  This creates both\n * `tokenizeInline` and `tokenizeBlock`.\n *\n * @example\n *   Parser.prototype.tokenizeInline = tokenizeFactory('inline');\n *\n * @param {string} type - Name of parser, used to find\n *   its expressions (`%sMethods`) and tokenizers\n *   (`%Tokenizers`).\n * @return {Function} - Tokenizer.\n */\nfunction tokenizeFactory(type) {\n    /**\n     * Tokenizer for a bound `type`\n     *\n     * @example\n     *   parser = new Parser();\n     *   parser.tokenizeInline('_foo_');\n     *\n     * @param {string} value - Content.\n     * @param {Object} location - Offset at which `value`\n     *   starts.\n     * @return {Array.<Object>} - Nodes.\n     */\n    function tokenize(value, location) {\n        var self = this;\n        var offset = self.offset;\n        var tokens = [];\n        var methods = self[type + 'Methods'];\n        var tokenizers = self[type + 'Tokenizers'];\n        var line = location.line;\n        var column = location.column;\n        var add;\n        var index;\n        var length;\n        var method;\n        var name;\n        var matched;\n        var valueLength;\n\n        /*\n         * Trim white space only lines.\n         */\n\n        if (!value) {\n            return tokens;\n        }\n\n        /**\n         * Update line, column, and offset based on\n         * `value`.\n         *\n         * @example\n         *   updatePosition('foo');\n         *\n         * @param {string} subvalue - Subvalue to eat.\n         */\n        function updatePosition(subvalue) {\n            var lastIndex = -1;\n            var index = subvalue.indexOf(C_NEWLINE);\n\n            while (index !== -1) {\n                line++;\n                lastIndex = index;\n                index = subvalue.indexOf(C_NEWLINE, index + 1);\n            }\n\n            if (lastIndex === -1) {\n                column += subvalue.length;\n            } else {\n                column = subvalue.length - lastIndex;\n            }\n\n            if (line in offset) {\n                if (lastIndex !== -1) {\n                    column += offset[line];\n                } else if (column <= offset[line]) {\n                    column = offset[line] + 1;\n                }\n            }\n        }\n\n        /**\n         * Get offset. Called before the first character is\n         * eaten to retrieve the range's offsets.\n         *\n         * @return {Function} - `done`, to be called when\n         *   the last character is eaten.\n         */\n        function getOffset() {\n            var indentation = [];\n            var pos = line + 1;\n\n            /**\n             * Done. Called when the last character is\n             * eaten to retrieve the ranges offsets.\n             *\n             * @return {Array.<number>} - Offset.\n             */\n            function done() {\n                var last = line + 1;\n\n                while (pos < last) {\n                    indentation.push((offset[pos] || 0) + 1);\n\n                    pos++;\n                }\n\n                return indentation;\n            }\n\n            return done;\n        }\n\n        /**\n         * Get the current position.\n         *\n         * @example\n         *   position = now(); // {line: 1, column: 1, offset: 0}\n         *\n         * @return {Object} - Current Position.\n         */\n        function now() {\n            var pos = {\n                'line': line,\n                'column': column\n            };\n\n            pos.offset = self.toOffset(pos);\n\n            return pos;\n        }\n\n        /**\n         * Store position information for a node.\n         *\n         * @example\n         *   start = now();\n         *   updatePosition('foo');\n         *   location = new Position(start);\n         *   // {\n         *   //   start: {line: 1, column: 1, offset: 0},\n         *   //   end: {line: 1, column: 3, offset: 2}\n         *   // }\n         *\n         * @param {Object} start - Starting position.\n         */\n        function Position(start) {\n            this.start = start;\n            this.end = now();\n        }\n\n        /**\n         * Throw when a value is incorrectly eaten.\n         * This shouldnt happen but will throw on new,\n         * incorrect rules.\n         *\n         * @example\n         *   // When the current value is set to `foo bar`.\n         *   validateEat('foo');\n         *   eat('foo');\n         *\n         *   validateEat('bar');\n         *   // throws, because the space is not eaten.\n         *\n         * @param {string} subvalue - Value to be eaten.\n         * @throws {Error} - When `subvalue` cannot be eaten.\n         */\n        function validateEat(subvalue) {\n            /* istanbul ignore if */\n            if (value.substring(0, subvalue.length) !== subvalue) {\n                self.file.fail(ERR_INCORRECTLY_EATEN, now());\n            }\n        }\n\n        /**\n         * Mark position and patch `node.position`.\n         *\n         * @example\n         *   var update = position();\n         *   updatePosition('foo');\n         *   update({});\n         *   // {\n         *   //   position: {\n         *   //     start: {line: 1, column: 1, offset: 0},\n         *   //     end: {line: 1, column: 3, offset: 2}\n         *   //   }\n         *   // }\n         *\n         * @returns {Function} - Updater.\n         */\n        function position() {\n            var before = now();\n\n            /**\n             * Add the position to a node.\n             *\n             * @example\n             *   update({type: 'text', value: 'foo'});\n             *\n             * @param {Node} node - Node to attach position\n             *   on.\n             * @param {Array} [indent] - Indentation for\n             *   `node`.\n             * @return {Node} - `node`.\n             */\n            function update(node, indent) {\n                var prev = node.position;\n                var start = prev ? prev.start : before;\n                var combined = [];\n                var n = prev && prev.end.line;\n                var l = before.line;\n\n                node.position = new Position(start);\n\n                /*\n                 * If there was already a `position`, this\n                 * node was merged.  Fixing `start` wasnt\n                 * hard, but the indent is different.\n                 * Especially because some information, the\n                 * indent between `n` and `l` wasnt\n                 * tracked.  Luckily, that space is\n                 * (should be?) empty, so we can safely\n                 * check for it now.\n                 */\n\n                if (prev && indent && prev.indent) {\n                    combined = prev.indent;\n\n                    if (n < l) {\n                        while (++n < l) {\n                            combined.push((offset[n] || 0) + 1);\n                        }\n\n                        combined.push(before.column);\n                    }\n\n                    indent = combined.concat(indent);\n                }\n\n                node.position.indent = indent || [];\n\n                return node;\n            }\n\n            return update;\n        }\n\n        /**\n         * Add `node` to `parent`s children or to `tokens`.\n         * Performs merges where possible.\n         *\n         * @example\n         *   add({});\n         *\n         *   add({}, {children: []});\n         *\n         * @param {Object} node - Node to add.\n         * @param {Object} [parent] - Parent to insert into.\n         * @return {Object} - Added or merged into node.\n         */\n        add = function (node, parent) {\n            var prev;\n            var children;\n\n            if (!parent) {\n                children = tokens;\n            } else {\n                children = parent.children;\n            }\n\n            prev = children[children.length - 1];\n\n            if (\n                prev &&\n                node.type === prev.type &&\n                node.type in MERGEABLE_NODES &&\n                mergeable(prev) &&\n                mergeable(node)\n            ) {\n                node = MERGEABLE_NODES[node.type].call(\n                    self, prev, node\n                );\n            }\n\n            if (node !== prev) {\n                children.push(node);\n            }\n\n            if (self.atStart && tokens.length) {\n                self.exitStart();\n            }\n\n            return node;\n        };\n\n        /**\n         * Remove `subvalue` from `value`.\n         * `subvalue` must be at the start of `value`.\n         *\n         * @example\n         *   eat('foo')({type: 'text', value: 'foo'});\n         *\n         * @param {string} subvalue - Removed from `value`,\n         *   and passed to `updatePosition`.\n         * @return {Function} - Wrapper around `add`, which\n         *   also adds `position` to node.\n         */\n        function eat(subvalue) {\n            var indent = getOffset();\n            var pos = position();\n            var current = now();\n\n            validateEat(subvalue);\n\n            /**\n             * Add the given arguments, add `position` to\n             * the returned node, and return the node.\n             *\n             * @param {Object} node - Node to add.\n             * @param {Object} [parent] - Node to insert into.\n             * @return {Node} - Added node.\n             */\n            function apply(node, parent) {\n                return pos(add(pos(node), parent), indent);\n            }\n\n            /**\n             * Functions just like apply, but resets the\n             * content:  the line and column are reversed,\n             * and the eaten value is re-added.\n             *\n             * This is useful for nodes with a single\n             * type of content, such as lists and tables.\n             *\n             * See `apply` above for what parameters are\n             * expected.\n             *\n             * @return {Node} - Added node.\n             */\n            function reset() {\n                var node = apply.apply(null, arguments);\n\n                line = current.line;\n                column = current.column;\n                value = subvalue + value;\n\n                return node;\n            }\n\n            /**\n             * Test the position, after eating, and reverse\n             * to a not-eaten state.\n             *\n             * @return {Position} - Position after eating `subvalue`.\n             */\n            function test() {\n                var result = pos({});\n\n                line = current.line;\n                column = current.column;\n                value = subvalue + value;\n\n                return result.position;\n            }\n\n            apply.reset = reset;\n            apply.test = reset.test = test;\n\n            value = value.substring(subvalue.length);\n\n            updatePosition(subvalue);\n\n            indent = indent();\n\n            return apply;\n        }\n\n        /*\n         * Expose `now` on `eat`.\n         */\n\n        eat.now = now;\n\n        /*\n         * Expose `file` on `eat`.\n         */\n\n        eat.file = self.file;\n\n        /*\n         * Sync initial offset.\n         */\n\n        updatePosition(EMPTY);\n\n        /*\n         * Iterate over `value`, and iterate over all\n         * tokenizers.  When one eats something, re-iterate\n         * with the remaining value.  If no tokenizer eats,\n         * something failed (should not happen) and an\n         * exception is thrown.\n         */\n\n        while (value) {\n            index = -1;\n            length = methods.length;\n            matched = false;\n\n            while (++index < length) {\n                name = methods[index];\n                method = tokenizers[name];\n\n                if (\n                    method &&\n                    (!method.onlyAtStart || self.atStart) &&\n                    (!method.notInList || !self.inList) &&\n                    (!method.notInBlock || !self.inBlock) &&\n                    (!method.notInLink || !self.inLink)\n                ) {\n                    valueLength = value.length;\n\n                    method.apply(self, [eat, value]);\n\n                    matched = valueLength !== value.length;\n\n                    if (matched) {\n                        break;\n                    }\n                }\n            }\n\n            /* istanbul ignore if */\n            if (!matched) {\n                self.file.fail(ERR_INFINITE_LOOP, eat.now());\n\n                /*\n                 * Errors are not thrown on `File#fail`\n                 * when `quiet: true`.\n                 */\n\n                break;\n            }\n        }\n\n        self.eof = now();\n\n        return tokens;\n    }\n\n    return tokenize;\n}\n\n/*\n * Expose tokenizers for block-level nodes.\n */\n\nParser.prototype.blockTokenizers = {\n    'yamlFrontMatter': tokenizeYAMLFrontMatter,\n    'newline': tokenizeNewline,\n    'indentedCode': tokenizeIndentedCode,\n    'fencedCode': tokenizeFencedCode,\n    'blockquote': tokenizeBlockquote,\n    'atxHeading': tokenizeATXHeading,\n    'thematicBreak': tokenizeThematicBreak,\n    'list': tokenizeList,\n    'setextHeading': tokenizeSetextHeading,\n    'html': tokenizeBlockHTML,\n    'footnote': tokenizeFootnoteDefinition,\n    'definition': tokenizeDefinition,\n    'table': tokenizeTable,\n    'paragraph': tokenizeParagraph\n};\n\n/*\n * Expose order in which to parse block-level nodes.\n */\n\nParser.prototype.blockMethods = [\n    'yamlFrontMatter',\n    'newline',\n    'indentedCode',\n    'fencedCode',\n    'blockquote',\n    'atxHeading',\n    'thematicBreak',\n    'list',\n    'setextHeading',\n    'html',\n    'footnote',\n    'definition',\n    'table',\n    'paragraph'\n];\n\n/**\n * Block tokenizer.\n *\n * @example\n *   var parser = new Parser();\n *   parser.tokenizeBlock('> foo.');\n *\n * @param {string} value - Content.\n * @return {Array.<Object>} - Nodes.\n */\n\nParser.prototype.tokenizeBlock = tokenizeFactory(BLOCK);\n\n/*\n * Expose tokenizers for inline-level nodes.\n */\n\nParser.prototype.inlineTokenizers = {\n    'escape': tokenizeEscape,\n    'autoLink': tokenizeAutoLink,\n    'url': tokenizeURL,\n    'html': tokenizeInlineHTML,\n    'link': tokenizeLink,\n    'reference': tokenizeReference,\n    'strong': tokenizeStrong,\n    'emphasis': tokenizeEmphasis,\n    'deletion': tokenizeDeletion,\n    'code': tokenizeInlineCode,\n    'break': tokenizeBreak,\n    'text': tokenizeText\n};\n\n/*\n * Expose order in which to parse inline-level nodes.\n */\n\nParser.prototype.inlineMethods = [\n    'escape',\n    'autoLink',\n    'url',\n    'html',\n    'link',\n    'reference',\n    'strong',\n    'emphasis',\n    'deletion',\n    'code',\n    'break',\n    'text'\n];\n\n/**\n * Inline tokenizer.\n *\n * @example\n *   var parser = new Parser();\n *   parser.tokenizeInline('_foo_');\n *\n * @param {string} value - Content.\n * @return {Array.<Object>} - Nodes.\n */\n\nParser.prototype.tokenizeInline = tokenizeFactory(INLINE);\n\n/*\n * Expose `tokenizeFactory` so dependencies could create\n * their own tokenizers.\n */\n\nParser.prototype.tokenizeFactory = tokenizeFactory;\n\n/*\n * Expose `attacher`.\n */\n\nmodule.exports = Parser;\n","'use strict'\n\nvar legacy = require('character-entities-legacy')\nvar invalid = require('character-reference-invalid')\nvar decimal = require('is-decimal')\nvar hexadecimal = require('is-hexadecimal')\nvar alphanumerical = require('is-alphanumerical')\nvar decodeEntity = require('./decode-entity')\n\nmodule.exports = parseEntities\n\nvar own = {}.hasOwnProperty\nvar fromCharCode = String.fromCharCode\nvar noop = Function.prototype\n\n/* Default settings. */\nvar defaults = {\n  warning: null,\n  reference: null,\n  text: null,\n  warningContext: null,\n  referenceContext: null,\n  textContext: null,\n  position: {},\n  additional: null,\n  attribute: false,\n  nonTerminated: true\n}\n\n/* Reference types. */\nvar NAMED = 'named'\nvar HEXADECIMAL = 'hexadecimal'\nvar DECIMAL = 'decimal'\n\n/* Map of bases. */\nvar BASE = {}\n\nBASE[HEXADECIMAL] = 16\nBASE[DECIMAL] = 10\n\n/* Map of types to tests. Each type of character reference\n * accepts different characters. This test is used to\n * detect whether a reference has ended (as the semicolon\n * is not strictly needed). */\nvar TESTS = {}\n\nTESTS[NAMED] = alphanumerical\nTESTS[DECIMAL] = decimal\nTESTS[HEXADECIMAL] = hexadecimal\n\n/* Warning messages. */\nvar NAMED_NOT_TERMINATED = 1\nvar NUMERIC_NOT_TERMINATED = 2\nvar NAMED_EMPTY = 3\nvar NUMERIC_EMPTY = 4\nvar NAMED_UNKNOWN = 5\nvar NUMERIC_DISALLOWED = 6\nvar NUMERIC_PROHIBITED = 7\n\nvar MESSAGES = {}\n\nMESSAGES[NAMED_NOT_TERMINATED] =\n  'Named character references must be terminated by a semicolon'\nMESSAGES[NUMERIC_NOT_TERMINATED] =\n  'Numeric character references must be terminated by a semicolon'\nMESSAGES[NAMED_EMPTY] = 'Named character references cannot be empty'\nMESSAGES[NUMERIC_EMPTY] = 'Numeric character references cannot be empty'\nMESSAGES[NAMED_UNKNOWN] = 'Named character references must be known'\nMESSAGES[NUMERIC_DISALLOWED] =\n  'Numeric character references cannot be disallowed'\nMESSAGES[NUMERIC_PROHIBITED] =\n  'Numeric character references cannot be outside the permissible Unicode range'\n\n/* Wrap to ensure clean parameters are given to `parse`. */\nfunction parseEntities(value, options) {\n  var settings = {}\n  var option\n  var key\n\n  if (!options) {\n    options = {}\n  }\n\n  for (key in defaults) {\n    option = options[key]\n    settings[key] =\n      option === null || option === undefined ? defaults[key] : option\n  }\n\n  if (settings.position.indent || settings.position.start) {\n    settings.indent = settings.position.indent || []\n    settings.position = settings.position.start\n  }\n\n  return parse(value, settings)\n}\n\n/* Parse entities. */\nfunction parse(value, settings) {\n  var additional = settings.additional\n  var nonTerminated = settings.nonTerminated\n  var handleText = settings.text\n  var handleReference = settings.reference\n  var handleWarning = settings.warning\n  var textContext = settings.textContext\n  var referenceContext = settings.referenceContext\n  var warningContext = settings.warningContext\n  var pos = settings.position\n  var indent = settings.indent || []\n  var length = value.length\n  var index = 0\n  var lines = -1\n  var column = pos.column || 1\n  var line = pos.line || 1\n  var queue = ''\n  var result = []\n  var entityCharacters\n  var namedEntity\n  var terminated\n  var characters\n  var character\n  var reference\n  var following\n  var warning\n  var reason\n  var output\n  var entity\n  var begin\n  var start\n  var type\n  var test\n  var prev\n  var next\n  var diff\n  var end\n\n  /* Cache the current point. */\n  prev = now()\n\n  /* Wrap `handleWarning`. */\n  warning = handleWarning ? parseError : noop\n\n  /* Ensure the algorithm walks over the first character\n   * and the end (inclusive). */\n  index--\n  length++\n\n  while (++index < length) {\n    /* If the previous character was a newline. */\n    if (character === '\\n') {\n      column = indent[lines] || 1\n    }\n\n    character = at(index)\n\n    /* Handle anything other than an ampersand,\n     * including newlines and EOF. */\n    if (character !== '&') {\n      if (character === '\\n') {\n        line++\n        lines++\n        column = 0\n      }\n\n      if (character) {\n        queue += character\n        column++\n      } else {\n        flush()\n      }\n    } else {\n      following = at(index + 1)\n\n      /* The behaviour depends on the identity of the next\n       * character. */\n      if (\n        following === '\\t' /* Tab */ ||\n        following === '\\n' /* Newline */ ||\n        following === '\\f' /* Form feed */ ||\n        following === ' ' /* Space */ ||\n        following === '<' /* Less-than */ ||\n        following === '&' /* Ampersand */ ||\n        following === '' ||\n        (additional && following === additional)\n      ) {\n        /* Not a character reference. No characters\n         * are consumed, and nothing is returned.\n         * This is not an error, either. */\n        queue += character\n        column++\n\n        continue\n      }\n\n      start = index + 1\n      begin = start\n      end = start\n\n      /* Numerical entity. */\n      if (following !== '#') {\n        type = NAMED\n      } else {\n        end = ++begin\n\n        /* The behaviour further depends on the\n         * character after the U+0023 NUMBER SIGN. */\n        following = at(end)\n\n        if (following === 'x' || following === 'X') {\n          /* ASCII hex digits. */\n          type = HEXADECIMAL\n          end = ++begin\n        } else {\n          /* ASCII digits. */\n          type = DECIMAL\n        }\n      }\n\n      entityCharacters = ''\n      entity = ''\n      characters = ''\n      test = TESTS[type]\n      end--\n\n      while (++end < length) {\n        following = at(end)\n\n        if (!test(following)) {\n          break\n        }\n\n        characters += following\n\n        /* Check if we can match a legacy named\n         * reference.  If so, we cache that as the\n         * last viable named reference.  This\n         * ensures we do not need to walk backwards\n         * later. */\n        if (type === NAMED && own.call(legacy, characters)) {\n          entityCharacters = characters\n          entity = legacy[characters]\n        }\n      }\n\n      terminated = at(end) === ';'\n\n      if (terminated) {\n        end++\n\n        namedEntity = type === NAMED ? decodeEntity(characters) : false\n\n        if (namedEntity) {\n          entityCharacters = characters\n          entity = namedEntity\n        }\n      }\n\n      diff = 1 + end - start\n\n      if (!terminated && !nonTerminated) {\n        /* Empty. */\n      } else if (!characters) {\n        /* An empty (possible) entity is valid, unless\n         * its numeric (thus an ampersand followed by\n         * an octothorp). */\n        if (type !== NAMED) {\n          warning(NUMERIC_EMPTY, diff)\n        }\n      } else if (type === NAMED) {\n        /* An ampersand followed by anything\n         * unknown, and not terminated, is invalid. */\n        if (terminated && !entity) {\n          warning(NAMED_UNKNOWN, 1)\n        } else {\n          /* If theres something after an entity\n           * name which is not known, cap the\n           * reference. */\n          if (entityCharacters !== characters) {\n            end = begin + entityCharacters.length\n            diff = 1 + end - begin\n            terminated = false\n          }\n\n          /* If the reference is not terminated,\n           * warn. */\n          if (!terminated) {\n            reason = entityCharacters ? NAMED_NOT_TERMINATED : NAMED_EMPTY\n\n            if (!settings.attribute) {\n              warning(reason, diff)\n            } else {\n              following = at(end)\n\n              if (following === '=') {\n                warning(reason, diff)\n                entity = null\n              } else if (alphanumerical(following)) {\n                entity = null\n              } else {\n                warning(reason, diff)\n              }\n            }\n          }\n        }\n\n        reference = entity\n      } else {\n        if (!terminated) {\n          /* All non-terminated numeric entities are\n           * not rendered, and trigger a warning. */\n          warning(NUMERIC_NOT_TERMINATED, diff)\n        }\n\n        /* When terminated and number, parse as\n         * either hexadecimal or decimal. */\n        reference = parseInt(characters, BASE[type])\n\n        /* Trigger a warning when the parsed number\n         * is prohibited, and replace with\n         * replacement character. */\n        if (prohibited(reference)) {\n          warning(NUMERIC_PROHIBITED, diff)\n          reference = '\\uFFFD'\n        } else if (reference in invalid) {\n          /* Trigger a warning when the parsed number\n           * is disallowed, and replace by an\n           * alternative. */\n          warning(NUMERIC_DISALLOWED, diff)\n          reference = invalid[reference]\n        } else {\n          /* Parse the number. */\n          output = ''\n\n          /* Trigger a warning when the parsed\n           * number should not be used. */\n          if (disallowed(reference)) {\n            warning(NUMERIC_DISALLOWED, diff)\n          }\n\n          /* Stringify the number. */\n          if (reference > 0xffff) {\n            reference -= 0x10000\n            output += fromCharCode((reference >>> (10 & 0x3ff)) | 0xd800)\n            reference = 0xdc00 | (reference & 0x3ff)\n          }\n\n          reference = output + fromCharCode(reference)\n        }\n      }\n\n      /* If we could not find a reference, queue the\n       * checked characters (as normal characters),\n       * and move the pointer to their end. This is\n       * possible because we can be certain neither\n       * newlines nor ampersands are included. */\n      if (!reference) {\n        characters = value.slice(start - 1, end)\n        queue += characters\n        column += characters.length\n        index = end - 1\n      } else {\n        /* Found it! First eat the queued\n         * characters as normal text, then eat\n         * an entity. */\n        flush()\n\n        prev = now()\n        index = end - 1\n        column += end - start + 1\n        result.push(reference)\n        next = now()\n        next.offset++\n\n        if (handleReference) {\n          handleReference.call(\n            referenceContext,\n            reference,\n            {start: prev, end: next},\n            value.slice(start - 1, end)\n          )\n        }\n\n        prev = next\n      }\n    }\n  }\n\n  /* Return the reduced nodes, and any possible warnings. */\n  return result.join('')\n\n  /* Get current position. */\n  function now() {\n    return {\n      line: line,\n      column: column,\n      offset: index + (pos.offset || 0)\n    }\n  }\n\n  /* Throw a parse-error: a warning. */\n  function parseError(code, offset) {\n    var position = now()\n\n    position.column += offset\n    position.offset += offset\n\n    handleWarning.call(warningContext, MESSAGES[code], position, code)\n  }\n\n  /* Get character at position. */\n  function at(position) {\n    return value.charAt(position)\n  }\n\n  /* Flush `queue` (normal text). Macro invoked before\n   * each entity and at the end of `value`.\n   * Does nothing when `queue` is empty. */\n  function flush() {\n    if (queue) {\n      result.push(queue)\n\n      if (handleText) {\n        handleText.call(textContext, queue, {start: prev, end: now()})\n      }\n\n      queue = ''\n    }\n  }\n}\n\n/* Check if `character` is outside the permissible unicode range. */\nfunction prohibited(code) {\n  return (code >= 0xd800 && code <= 0xdfff) || code > 0x10ffff\n}\n\n/* Check if `character` is disallowed. */\nfunction disallowed(code) {\n  return (\n    (code >= 0x0001 && code <= 0x0008) ||\n    code === 0x000b ||\n    (code >= 0x000d && code <= 0x001f) ||\n    (code >= 0x007f && code <= 0x009f) ||\n    (code >= 0xfdd0 && code <= 0xfdef) ||\n    (code & 0xffff) === 0xffff ||\n    (code & 0xffff) === 0xfffe\n  )\n}\n","'use strict'\n\nmodule.exports = hexadecimal\n\n/* Check if the given character code, or the character\n * code at the first character, is hexadecimal. */\nfunction hexadecimal(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 /* a */ && code <= 102) /* z */ ||\n    (code >= 65 /* A */ && code <= 70) /* Z */ ||\n    (code >= 48 /* A */ && code <= 57) /* Z */\n  )\n}\n","'use strict'\n\nvar alphabetical = require('is-alphabetical')\nvar decimal = require('is-decimal')\n\nmodule.exports = alphanumerical\n\n/* Check if the given character code, or the character\n * code at the first character, is alphanumerical. */\nfunction alphanumerical(character) {\n  return alphabetical(character) || decimal(character)\n}\n","'use strict'\n\nmodule.exports = alphabetical\n\n/* Check if the given character code, or the character\n * code at the first character, is alphabetical. */\nfunction alphabetical(character) {\n  var code = typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 && code <= 122) /* a-z */ ||\n    (code >= 65 && code <= 90) /* A-Z */\n  )\n}\n","'use strict'\n\n/* eslint-env browser */\n\nvar el\n\nmodule.exports = decodeEntity\n\nfunction decodeEntity(characters) {\n  var entity = '&' + characters + ';'\n  var char\n\n  el = el || document.createElement('i')\n  el.innerHTML = entity\n  char = el.textContent\n\n  // Some entities do not require the closing semicolon (&not - for instance),\n  // which leads to situations where parsing the assumed entity of &notit; will\n  // result in the string `it;`.  When we encounter a trailing semicolon after\n  // parsing and the entity to decode was not a semicolon (&semi;), we can\n  // assume that the matching was incomplete\n  if (char.slice(-1) === ';' && characters !== 'semi') {\n    return false\n  }\n\n  // If the decoded string is equal to the input, the entity was not valid\n  return char === entity ? false : char\n}\n","/*!\n * repeat-string <https://github.com/jonschlinkert/repeat-string>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Results cache\n */\n\nvar res = '';\nvar cache;\n\n/**\n * Expose `repeat`\n */\n\nmodule.exports = repeat;\n\n/**\n * Repeat the given `string` the specified `number`\n * of times.\n *\n * **Example:**\n *\n * ```js\n * var repeat = require('repeat-string');\n * repeat('A', 5);\n * //=> AAAAA\n * ```\n *\n * @param {String} `string` The string to repeat\n * @param {Number} `number` The number of times to repeat the string\n * @return {String} Repeated string\n * @api public\n */\n\nfunction repeat(str, num) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  // cover common, quick use cases\n  if (num === 1) return str;\n  if (num === 2) return str + str;\n\n  var max = str.length * num;\n  if (cache !== str || typeof cache === 'undefined') {\n    cache = str;\n    res = '';\n  } else if (res.length >= max) {\n    return res.substr(0, max);\n  }\n\n  while (max > res.length && num > 1) {\n    if (num & 1) {\n      res += str;\n    }\n\n    num >>= 1;\n    str += str;\n  }\n\n  res += str;\n  res = res.substr(0, max);\n  return res;\n}\n","\nexports = module.exports = trim;\n\nfunction trim(str){\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function(str){\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function(str){\n  return str.replace(/\\s*$/, '');\n};\n","'use strict'\n\nmodule.exports = trimTrailingLines\n\nvar line = '\\n'\n\n/* Remove final newline characters from `value`. */\nfunction trimTrailingLines(value) {\n  var val = String(value)\n  var index = val.length\n\n  while (val.charAt(--index) === line) {\n    /* Empty */\n  }\n\n  return val.slice(0, index + 1)\n}\n","'use strict'\n\nmodule.exports = factory\n\nfunction factory(file) {\n  var contents = indices(String(file))\n\n  return {\n    toPosition: offsetToPositionFactory(contents),\n    toOffset: positionToOffsetFactory(contents)\n  }\n}\n\n// Factory to get the line and column-based `position` for `offset` in the bound\n// indices.\nfunction offsetToPositionFactory(indices) {\n  return offsetToPosition\n\n  // Get the line and column-based `position` for `offset` in the bound indices.\n  function offsetToPosition(offset) {\n    var index = -1\n    var length = indices.length\n\n    if (offset < 0) {\n      return {}\n    }\n\n    while (++index < length) {\n      if (indices[index] > offset) {\n        return {\n          line: index + 1,\n          column: offset - (indices[index - 1] || 0) + 1,\n          offset: offset\n        }\n      }\n    }\n\n    return {}\n  }\n}\n\n// Factory to get the `offset` for a line and column-based `position` in the\n// bound indices.\nfunction positionToOffsetFactory(indices) {\n  return positionToOffset\n\n  // Get the `offset` for a line and column-based `position` in the bound\n  // indices.\n  function positionToOffset(position) {\n    var line = position && position.line\n    var column = position && position.column\n\n    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {\n      return (indices[line - 2] || 0) + column - 1 || 0\n    }\n\n    return -1\n  }\n}\n\n// Get indices of line-breaks in `value`.\nfunction indices(value) {\n  var result = []\n  var index = value.indexOf('\\n')\n\n  while (index !== -1) {\n    result.push(index + 1)\n    index = value.indexOf('\\n', index + 1)\n  }\n\n  result.push(value.length + 1)\n\n  return result\n}\n","'use strict'\n\nvar visit = require('unist-util-visit')\n\nmodule.exports = removePosition\n\n/* Remove `position`s from `tree`. */\nfunction removePosition(node, force) {\n  visit(node, force ? hard : soft)\n  return node\n}\n\nfunction hard(node) {\n  delete node.position\n}\n\nfunction soft(node) {\n  node.position = undefined\n}\n","'use strict'\n\n/* eslint-disable max-params */\n\n/* Expose. */\nmodule.exports = is\n\n/* Assert if `test` passes for `node`.\n * When a `parent` node is known the `index` of node */\nfunction is(test, node, index, parent, context) {\n  var hasParent = parent !== null && parent !== undefined\n  var hasIndex = index !== null && index !== undefined\n  var check = convert(test)\n\n  if (\n    hasIndex &&\n    (typeof index !== 'number' || index < 0 || index === Infinity)\n  ) {\n    throw new Error('Expected positive finite index or child node')\n  }\n\n  if (hasParent && (!is(null, parent) || !parent.children)) {\n    throw new Error('Expected parent node')\n  }\n\n  if (!node || !node.type || typeof node.type !== 'string') {\n    return false\n  }\n\n  if (hasParent !== hasIndex) {\n    throw new Error('Expected both parent and index')\n  }\n\n  return Boolean(check.call(context, node, index, parent))\n}\n\nfunction convert(test) {\n  if (typeof test === 'string') {\n    return typeFactory(test)\n  }\n\n  if (test === null || test === undefined) {\n    return ok\n  }\n\n  if (typeof test === 'object') {\n    return ('length' in test ? anyFactory : matchesFactory)(test)\n  }\n\n  if (typeof test === 'function') {\n    return test\n  }\n\n  throw new Error('Expected function, string, or object as test')\n}\n\nfunction convertAll(tests) {\n  var results = []\n  var length = tests.length\n  var index = -1\n\n  while (++index < length) {\n    results[index] = convert(tests[index])\n  }\n\n  return results\n}\n\n/* Utility assert each property in `test` is represented\n * in `node`, and each values are strictly equal. */\nfunction matchesFactory(test) {\n  return matches\n\n  function matches(node) {\n    var key\n\n    for (key in test) {\n      if (node[key] !== test[key]) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nfunction anyFactory(tests) {\n  var checks = convertAll(tests)\n  var length = checks.length\n\n  return matches\n\n  function matches() {\n    var index = -1\n\n    while (++index < length) {\n      if (checks[index].apply(this, arguments)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/* Utility to convert a string into a function which checks\n * a given nodes type for said string. */\nfunction typeFactory(test) {\n  return type\n\n  function type(node) {\n    return Boolean(node && node.type === test)\n  }\n}\n\n/* Utility to return true. */\nfunction ok() {\n  return true\n}\n","'use strict'\n\nmodule.exports = collapse\n\n/* collapse(' \\t\\nbar \\nbaz\\t'); // ' bar baz ' */\nfunction collapse(value) {\n  return String(value).replace(/\\s+/g, ' ')\n}\n","/**\n * @author Titus Wormer\n * @copyright 2015-2016 Titus Wormer\n * @license MIT\n * @module remark:parse:defaults\n * @fileoverview Default options for `parse`.\n */\n\n'use strict';\n\n/* eslint-env commonjs */\n\nmodule.exports = {\n    'position': true,\n    'gfm': true,\n    'yaml': true,\n    'commonmark': false,\n    'footnotes': false,\n    'pedantic': false,\n    'breaks': false\n};\n","var visitWithParents = require('unist-util-visit-parents');\n\nfunction addListMetadata() {\n  return function (ast) {\n    visitWithParents(ast, 'list', function (listNode, parents) {\n      var depth = 0, i, n;\n      for (i = 0, n = parents.length; i < n; i++) {\n        if (parents[i].type === 'list') depth += 1;\n      }\n      for (i = 0, n = listNode.children.length; i < n; i++) {\n        var child = listNode.children[i];\n        child.index = i;\n        child.ordered = listNode.ordered;\n      }\n      listNode.depth = depth;\n    });\n    return ast;\n  };\n}\n\nmodule.exports = addListMetadata;\n","\"use strict\";\n\n/**\n * Naive, simple plugin to match inline nodes without attributes\n * This allows say <strong>foo</strong>, but not <strong class=\"very\">foo</strong>\n * For proper HTML support, you'll want a different plugin\n **/\nvar visit = require('unist-util-visit');\n\nvar type = 'virtualHtml';\nvar selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\\s*\\/?>$/i;\nvar simpleTagRe = /^<(\\/?)([a-z]+)\\s*>$/;\n\nmodule.exports = function (tree) {\n  var open;\n  var currentParent;\n  visit(tree, 'html', function (node, index, parent) {\n    if (currentParent !== parent) {\n      open = [];\n      currentParent = parent;\n    }\n\n    var selfClosing = getSelfClosing(node);\n\n    if (selfClosing) {\n      parent.children.splice(index, 1, {\n        type: type,\n        tag: selfClosing,\n        position: node.position\n      });\n      return true;\n    }\n\n    var current = getSimpleTag(node, parent);\n\n    if (!current) {\n      return true;\n    }\n\n    var matching = findAndPull(open, current.tag);\n\n    if (matching) {\n      parent.children.splice(index, 0, virtual(current, matching, parent));\n    } else if (!current.opening) {\n      open.push(current);\n    }\n\n    return true;\n  }, true // Iterate in reverse\n  );\n  return tree;\n};\n\nfunction findAndPull(open, matchingTag) {\n  var i = open.length;\n\n  while (i--) {\n    if (open[i].tag === matchingTag) {\n      return open.splice(i, 1)[0];\n    }\n  }\n\n  return false;\n}\n\nfunction getSimpleTag(node, parent) {\n  var match = node.value.match(simpleTagRe);\n  return match ? {\n    tag: match[2],\n    opening: !match[1],\n    node: node\n  } : false;\n}\n\nfunction getSelfClosing(node) {\n  var match = node.value.match(selfClosingRe);\n  return match ? match[1] : false;\n}\n\nfunction virtual(fromNode, toNode, parent) {\n  var fromIndex = parent.children.indexOf(fromNode.node);\n  var toIndex = parent.children.indexOf(toNode.node);\n  var extracted = parent.children.splice(fromIndex, toIndex - fromIndex + 1);\n  var children = extracted.slice(1, -1);\n  return {\n    type: type,\n    children: children,\n    tag: fromNode.tag,\n    position: {\n      start: fromNode.node.position.start,\n      end: toNode.node.position.end,\n      indent: []\n    }\n  };\n}","\"use strict\";\n\nvar visit = require('unist-util-visit');\n\nexports.ofType = function (types, mode) {\n  return function (node) {\n    types.forEach(function (type) {\n      return visit(node, type, disallow, true);\n    });\n    return node;\n  };\n\n  function disallow(node, index, parent) {\n    if (parent) {\n      untangle(node, index, parent, mode);\n    }\n  }\n};\n\nexports.ifNotMatch = function (allowNode, mode) {\n  return function (node) {\n    visit(node, disallow, true);\n    return node;\n  };\n\n  function disallow(node, index, parent) {\n    if (parent && !allowNode(node, index, parent)) {\n      untangle(node, index, parent, mode);\n    }\n  }\n};\n\nfunction untangle(node, index, parent, mode) {\n  if (mode === 'remove') {\n    parent.children.splice(index, 1);\n  } else if (mode === 'unwrap') {\n    var args = [index, 1];\n\n    if (node.children) {\n      args = args.concat(node.children);\n    }\n\n    Array.prototype.splice.apply(parent.children, args);\n  }\n}","'use strict';\n\nvar React = require('react');\n\nvar xtend = require('xtend');\n\nfunction astToReact(node, options) {\n  var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var renderer = options.renderers[node.type];\n  var pos = node.position.start;\n  var key = [node.type, pos.line, pos.column].join('-');\n\n  if (typeof renderer !== 'function' && typeof renderer !== 'string' && !isReactFragment(renderer)) {\n    throw new Error(\"Renderer for type `\".concat(node.type, \"` not defined or is not renderable\"));\n  }\n\n  var nodeProps = getNodeProps(node, key, options, renderer, parent, index);\n  return React.createElement(renderer, nodeProps, nodeProps.children || resolveChildren() || undefined);\n\n  function resolveChildren() {\n    return node.children && node.children.map(function (childNode, i) {\n      return astToReact(childNode, options, {\n        node: node,\n        props: nodeProps\n      }, i);\n    });\n  }\n}\n\nfunction isReactFragment(renderer) {\n  return React.Fragment && React.Fragment === renderer;\n} // eslint-disable-next-line max-params, complexity\n\n\nfunction getNodeProps(node, key, opts, renderer, parent, index) {\n  var props = {\n    key: key\n  };\n  var isTagRenderer = typeof renderer === 'string'; // `sourcePos` is true if the user wants source information (line/column info from markdown source)\n\n  if (opts.sourcePos && node.position) {\n    props['data-sourcepos'] = flattenPosition(node.position);\n  }\n\n  if (opts.rawSourcePos && !isTagRenderer) {\n    props.sourcePosition = node.position;\n  } // If `includeNodeIndex` is true, pass node index info to all non-tag renderers\n\n\n  if (opts.includeNodeIndex && parent.node && parent.node.children && !isTagRenderer) {\n    props.index = parent.node.children.indexOf(node);\n    props.parentChildCount = parent.node.children.length;\n  }\n\n  var ref = node.identifier !== null && node.identifier !== undefined ? opts.definitions[node.identifier] || {} : null;\n\n  switch (node.type) {\n    case 'root':\n      assignDefined(props, {\n        className: opts.className\n      });\n      break;\n\n    case 'text':\n      props.nodeKey = key;\n      props.children = node.value;\n      break;\n\n    case 'heading':\n      props.level = node.depth;\n      break;\n\n    case 'list':\n      props.start = node.start;\n      props.ordered = node.ordered;\n      props.tight = !node.loose;\n      props.depth = node.depth;\n      break;\n\n    case 'listItem':\n      props.checked = node.checked;\n      props.tight = !node.loose;\n      props.ordered = node.ordered;\n      props.index = node.index;\n      props.children = getListItemChildren(node, parent).map(function (childNode, i) {\n        return astToReact(childNode, opts, {\n          node: node,\n          props: props\n        }, i);\n      });\n      break;\n\n    case 'definition':\n      assignDefined(props, {\n        identifier: node.identifier,\n        title: node.title,\n        url: node.url\n      });\n      break;\n\n    case 'code':\n      assignDefined(props, {\n        language: node.lang && node.lang.split(/\\s/, 1)[0]\n      });\n      break;\n\n    case 'inlineCode':\n      props.children = node.value;\n      props.inline = true;\n      break;\n\n    case 'link':\n      assignDefined(props, {\n        title: node.title || undefined,\n        target: typeof opts.linkTarget === 'function' ? opts.linkTarget(node.url, node.children, node.title) : opts.linkTarget,\n        href: opts.transformLinkUri ? opts.transformLinkUri(node.url, node.children, node.title) : node.url\n      });\n      break;\n\n    case 'image':\n      assignDefined(props, {\n        alt: node.alt || undefined,\n        title: node.title || undefined,\n        src: opts.transformImageUri ? opts.transformImageUri(node.url, node.children, node.title, node.alt) : node.url\n      });\n      break;\n\n    case 'linkReference':\n      assignDefined(props, xtend(ref, {\n        href: opts.transformLinkUri ? opts.transformLinkUri(ref.href) : ref.href\n      }));\n      break;\n\n    case 'imageReference':\n      assignDefined(props, {\n        src: opts.transformImageUri && ref.href ? opts.transformImageUri(ref.href, node.children, ref.title, node.alt) : ref.href,\n        title: ref.title || undefined,\n        alt: node.alt || undefined\n      });\n      break;\n\n    case 'table':\n    case 'tableHead':\n    case 'tableBody':\n      props.columnAlignment = node.align;\n      break;\n\n    case 'tableRow':\n      props.isHeader = parent.node.type === 'tableHead';\n      props.columnAlignment = parent.props.columnAlignment;\n      break;\n\n    case 'tableCell':\n      assignDefined(props, {\n        isHeader: parent.props.isHeader,\n        align: parent.props.columnAlignment[index]\n      });\n      break;\n\n    case 'virtualHtml':\n      props.tag = node.tag;\n      break;\n\n    case 'html':\n      // @todo find a better way than this\n      props.isBlock = node.position.start.line !== node.position.end.line;\n      props.escapeHtml = opts.escapeHtml;\n      props.skipHtml = opts.skipHtml;\n      break;\n\n    case 'parsedHtml':\n      props.escapeHtml = opts.escapeHtml;\n      props.skipHtml = opts.skipHtml;\n      props.element = mergeNodeChildren(node, (node.children || []).map(function (child, i) {\n        return astToReact(child, opts, {\n          node: node,\n          props: props\n        }, i);\n      }));\n      break;\n\n    default:\n      assignDefined(props, xtend(node, {\n        type: undefined,\n        position: undefined,\n        children: undefined\n      }));\n  }\n\n  if (!isTagRenderer && node.value) {\n    props.value = node.value;\n  }\n\n  return props;\n}\n\nfunction assignDefined(target, attrs) {\n  for (var key in attrs) {\n    if (typeof attrs[key] !== 'undefined') {\n      target[key] = attrs[key];\n    }\n  }\n}\n\nfunction mergeNodeChildren(node, parsedChildren) {\n  var el = node.element;\n\n  if (Array.isArray(el)) {\n    var Fragment = React.Fragment || 'div';\n    return React.createElement(Fragment, null, el);\n  }\n\n  var children = (el.props.children || []).concat(parsedChildren);\n  return React.cloneElement(el, null, children);\n}\n\nfunction flattenPosition(pos) {\n  return [pos.start.line, ':', pos.start.column, '-', pos.end.line, ':', pos.end.column].map(String).join('');\n}\n\nfunction getListItemChildren(node, parent) {\n  if (node.loose) {\n    return node.children;\n  }\n\n  if (parent.node && node.index > 0 && parent.node.children[node.index - 1].loose) {\n    return node.children;\n  }\n\n  return unwrapParagraphs(node);\n}\n\nfunction unwrapParagraphs(node) {\n  return node.children.reduce(function (array, child) {\n    return array.concat(child.type === 'paragraph' ? child.children || [] : [child]);\n  }, []);\n}\n\nmodule.exports = astToReact;","'use strict';\n\nvar visit = require('unist-util-visit');\n\nmodule.exports = function (node) {\n  visit(node, 'table', wrap);\n  return node;\n};\n\nfunction wrap(table) {\n  var children = table.children;\n  table.children = [{\n    type: 'tableHead',\n    align: table.align,\n    children: [children[0]],\n    position: children[0].position\n  }];\n\n  if (children.length > 1) {\n    table.children.push({\n      type: 'tableBody',\n      align: table.align,\n      children: children.slice(1),\n      position: {\n        start: children[1].position.start,\n        end: children[children.length - 1].position.end\n      }\n    });\n  }\n}","'use strict';\n\nmodule.exports = function getDefinitions(node) {\n  var defs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return (node.children || []).reduce(function (definitions, child) {\n    if (child.type === 'definition') {\n      definitions[child.identifier] = {\n        href: child.url,\n        title: child.title\n      };\n    }\n\n    return getDefinitions(child, definitions);\n  }, defs);\n};","\"use strict\";\n\nvar protocols = ['http', 'https', 'mailto', 'tel'];\n\nmodule.exports = function uriTransformer(uri) {\n  var url = (uri || '').trim();\n  var first = url.charAt(0);\n\n  if (first === '#' || first === '/') {\n    return url;\n  }\n\n  var colon = url.indexOf(':');\n\n  if (colon === -1) {\n    return url;\n  }\n\n  var length = protocols.length;\n  var index = -1;\n\n  while (++index < length) {\n    var protocol = protocols[index];\n\n    if (colon === protocol.length && url.slice(0, protocol.length).toLowerCase() === protocol) {\n      return url;\n    }\n  }\n\n  index = url.indexOf('?');\n\n  if (index !== -1 && colon > index) {\n    return url;\n  }\n\n  index = url.indexOf('#');\n\n  if (index !== -1 && colon > index) {\n    return url;\n  } // eslint-disable-next-line no-script-url\n\n\n  return 'javascript:void(0)';\n};","/* eslint-disable react/prop-types, react/no-multi-comp */\n'use strict';\n\nvar xtend = require('xtend');\n\nvar React = require('react');\n\nvar supportsStringRender = parseInt((React.version || '16').slice(0, 2), 10) >= 16;\nvar createElement = React.createElement;\nmodule.exports = {\n  break: 'br',\n  paragraph: 'p',\n  emphasis: 'em',\n  strong: 'strong',\n  thematicBreak: 'hr',\n  blockquote: 'blockquote',\n  delete: 'del',\n  link: 'a',\n  image: 'img',\n  linkReference: 'a',\n  imageReference: 'img',\n  table: SimpleRenderer.bind(null, 'table'),\n  tableHead: SimpleRenderer.bind(null, 'thead'),\n  tableBody: SimpleRenderer.bind(null, 'tbody'),\n  tableRow: SimpleRenderer.bind(null, 'tr'),\n  tableCell: TableCell,\n  root: Root,\n  text: TextRenderer,\n  list: List,\n  listItem: ListItem,\n  definition: NullRenderer,\n  heading: Heading,\n  inlineCode: InlineCode,\n  code: CodeBlock,\n  html: Html,\n  virtualHtml: VirtualHtml,\n  parsedHtml: ParsedHtml\n};\n\nfunction TextRenderer(props) {\n  return supportsStringRender ? props.children : createElement('span', null, props.children);\n}\n\nfunction Root(props) {\n  var useFragment = !props.className;\n  var root = useFragment ? React.Fragment || 'div' : 'div';\n  return createElement(root, useFragment ? null : props, props.children);\n}\n\nfunction SimpleRenderer(tag, props) {\n  return createElement(tag, getCoreProps(props), props.children);\n}\n\nfunction TableCell(props) {\n  var style = props.align ? {\n    textAlign: props.align\n  } : undefined;\n  var coreProps = getCoreProps(props);\n  return createElement(props.isHeader ? 'th' : 'td', style ? xtend({\n    style: style\n  }, coreProps) : coreProps, props.children);\n}\n\nfunction Heading(props) {\n  return createElement(\"h\".concat(props.level), getCoreProps(props), props.children);\n}\n\nfunction List(props) {\n  var attrs = getCoreProps(props);\n\n  if (props.start !== null && props.start !== 1) {\n    attrs.start = props.start.toString();\n  }\n\n  return createElement(props.ordered ? 'ol' : 'ul', attrs, props.children);\n}\n\nfunction ListItem(props) {\n  var checkbox = null;\n\n  if (props.checked !== null) {\n    var checked = props.checked;\n    checkbox = createElement('input', {\n      type: 'checkbox',\n      checked: checked,\n      readOnly: true\n    });\n  }\n\n  return createElement('li', getCoreProps(props), checkbox, props.children);\n}\n\nfunction CodeBlock(props) {\n  var className = props.language && \"language-\".concat(props.language);\n  var code = createElement('code', className ? {\n    className: className\n  } : null, props.value);\n  return createElement('pre', getCoreProps(props), code);\n}\n\nfunction InlineCode(props) {\n  return createElement('code', getCoreProps(props), props.children);\n}\n\nfunction Html(props) {\n  if (props.skipHtml) {\n    return null;\n  }\n\n  var tag = props.isBlock ? 'div' : 'span';\n\n  if (props.escapeHtml) {\n    var comp = React.Fragment || tag;\n    return createElement(comp, null, props.value);\n  }\n\n  var nodeProps = {\n    dangerouslySetInnerHTML: {\n      __html: props.value\n    }\n  };\n  return createElement(tag, nodeProps);\n}\n\nfunction ParsedHtml(props) {\n  return props['data-sourcepos'] ? React.cloneElement(props.element, {\n    'data-sourcepos': props['data-sourcepos']\n  }) : props.element;\n}\n\nfunction VirtualHtml(props) {\n  return createElement(props.tag, getCoreProps(props), props.children);\n}\n\nfunction NullRenderer() {\n  return null;\n}\n\nfunction getCoreProps(props) {\n  return props['data-sourcepos'] ? {\n    'data-sourcepos': props['data-sourcepos']\n  } : {};\n}","\"use strict\";\n\nvar HtmlParser = '__RMD_HTML_PARSER__';\nexports.HtmlParser = typeof Symbol === 'undefined' ? HtmlParser : Symbol(HtmlParser);"],"sourceRoot":""}